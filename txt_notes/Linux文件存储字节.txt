Linux的文件的存储的字节：

当文件内容为123时：
1，文件长度为  4
2，文件内容为  123$
3，文件内容字节  0x 31 32 33 0A
				D  49 50 51 10

cat    输出为   123
cat -A 输出为   123$  (换行符)

编程时： Linux文件结束符的诡异
1，以getc等字符读取函数操作文件。可以得到文件结束符 == EOF。是成立的。
2，以fread等字节读取函数操作文件，文件结束符 == 10，换言之，！= EOF。是不成立的。

问题：
1，以字符方式操作时，我们可以避免操作到文件结束符。因为ch==EOF时我们就退出了。
2，但是，以字节操作文件时，文件结束符为10，不等于EOF，而且，文件内容只有123，三个字节时，完全读取文件时，结果是四个字节。这里就出现一个很严重的问题，即如何得到文件的真实内容，即去掉EOF的内容。
	首先，我们要得到文件的长度。这个长度是包涵了文件结束符10.
	其次，我们读入时，要判断返回的len是否等于文件长度，已表示文件是否读取到结束符。
	最后，读取到结束符后，我们要把最后一个字节，即文件结束符位替换为'\0'，以实现字符串的结束。否则，读取到的是一个数组，而不能作为字符串！字符串的要求是以\0结束。

这一点是非常诡异的。


printf():      123    (换行符是看不到的，但它会换行)

解决： 不要用字节来与EOF比较，而是使用提供的函数feof(fp)>0来表示文件已经到末尾。对于fread，最后一次读取，有内容，但feof(fp)也大于0，因此，如果要判断，最好在文件读取前判断是否已经到文件尾。适用于二进制和文本模式。在linux下都是二进制存储文件，不像windows可能按字符来存储。


