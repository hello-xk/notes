(相关文件： 求结构体成员的偏移.txt)
像list.h那样创建所有类型适用的优先队列：

首先，list.h是通过将类型里共有的一个成员list_head来组成链表，操作时通过该list_head里面里获得list_head的地址，继而找到与该成员绑定结构体的地址，继而得到结构体自身。
这个过程：
1，结构体的数据是通过 动态分配内存 存储的。这种优势在于，只需要记录地址，而不担心在调用过程空间被释放（除非用户自己释放）。
2，链表的操作过程，只是针对类型里共有的那个成员list_head. 一个独立的list_head作为头，然后新的list_head作为插入结点。依次类推，组成一个链表（只不过是双向的）。仍旧需要记录链表头： 作为头的哪个list_head.
3，


那么，转移到适用所有类型的 优先队列 如何？
1，只要每次都增加到链表尾部，那么list.h本身也可以实现队列结构，优先队列只不过在插入前先进行优先级比较，再插入到中间。所以，list.h是可以轻松实现优先队列。只需再封装一层。

但是问题？
1，数据仍旧需要通过 动态分配内存 存储。
2，除了需要共有一个list_head成员外，还需要处理priority优先级，故接口需要改为：
   list_add(&channel->list_member, &_main_loop.io_channel_list, int priority); //插入的list_head的地址值，链表头的地址值，优先级
   //优先级在内部处理，并在内部与结构体绑定，而不用暴露出来，用户不需要知道优先级存储在哪里。
   那么，优先级放在哪呢？
    1，可以放在list_head结构体里面增加一个priority。这样在list.h基础上修改list.h的接口和一点实现，这样可以避免再次封装。这样做的好处是，直接将list.h修改成自己需要的优先队列模块。
    2，你可以自己封装一个list_head2 = {list_head, int priority}; 然后在内部对priority进行处理后，再次调用list.h原版的list_add()插入对应位置。不过，这个要求list_head2在自定义结构体的头部，否则list.h计算的是list_head所在的list_head2的地址，而不是包含list_head2的数据结构体的地址了！放在开头才能避免错误！！
    3，不封装新结构体，而是要求每个数据结构体再包含一个成员int priority。然后提供一系列接口，这些接口是直接处理该结构体的，然后在函数内部抽取结构体的priority和list_head属性才进行list.h调用。但是，这样，这个优先队列其实只是针对某一个类型了！ 换成像list.h那样的接口吧。就是接口改为：
        priority_list_add(&member, &header, priority) {
            //处理priority, 找到要插入的位置
            list_add(member, header)    //调用list.h插入指定位置。 
        }
       这种做法，不破坏list.h，只是做了一层轻轻的封装，还是比较好的。
       
3，以上的思路，都是建立在，数据结构体是通过 动态内存分配 得到的，只需要在一个地方申请，记住地址就可以在任意地方使用。
   但是，如果应用在栈空间，上面的思路就显得不适用。主要因为，栈变量的生命周期只在其声明的函数内！你在接口里声明，出了接口就被释放了。当然，你可以在接口里建立一个静态变量存储。但是，这只能用于单例。（不同的模块，进入接口都访问同一个静态变量，所以是无法实现多例的，多例必须要求通过参数传入对象，接口负责修改传入的对象的数据，而不能保存在接口里。）
   
   继续回到使用栈空间的问题上。
   栈空间 能与 动态空间 有多大区别？  不一样都是内存空间么！
      struct io_channel {
          struct list_head list_member;   //结点-指针
          bool             mark_dead; /* mark that this channel is about to be destroyed */
      
          int              fd;
          io_channel_type  type;
          e_io_func        callback;  /* when fd is avaiable, this hook will be called */
          void *           user_data; /* user data for callback */
      
          union {
              struct timer_data  timer_data;
              struct server_socket_data server_socket_data;
              struct client_socket_data client_socket_data;
          };
      };
     io_channel[10];
   难道这样的栈空间就不可以通过共有成员list_member进行操作吗！
   
   从基础看起吧：
   1，因为是栈空间，且要支持不同类型，那么就是用数组来存储了。且是不同类型的数组。所以无论在哪里使用，都要声明不同类型的数组。那么，这些数组就得靠用户声明，模块内不可能控制。所以，基本要求是，用户声明不同类型的数组，然后将数组传入模块，让模块处理。模块内绝不可能进行声明！！（紧记）    
      栈限制了很多东西： 
      1，如果为void *成员，那么该成员需要被上层的栈存储，否则空间会被丢失。所以，假设栈的空间里都存储void *，接口调用者负责创建这个空间。
      2，简而言之，调用者需要创建这些栈空间。
      3，复制的时候，需要知道void *真实的类型。因为队列是要复制值，而不是指针。所以，要么需要该结构体的真实类型，要么知道它的空间的大小。
   2，接口模块的最大问题在于，要统一不同类型的入口函数。即接口的参数类型是对任何类型通用的。即无论任何类型，传入函数的参数都是一样的。
   3，list.h的思路是，传入结构共有的一个成员，然后通过成员找到结构，这样，所有类型都可以统一接口了。参数都是那个共有的成员。
   4，那么，这里的栈空间可不可以也这样呢？ 传入的只是数组里面某个元素中共有的一个成员的地址，比如说int priority的地址。貌似可以。不过，第一个元素的priority的地址必须传入，这样就可以通过第一个元素的&priority地址找到第一个元素的地址。
   5，循环队列中的front和rear放哪呢？
   6，最大问题是，如果要在宏里处理优先级，并且插入，那么宏会很大，而且还需要创建过程变量辅助，这样，宏就相当于一个排序+插入函数。而宏一般只是函数的一部分，通常是函数头，函数体还是由调用者编写。    
    

way1的问题：
1，不能在初始宏中调用函数。初始宏的主要作用是初始化变量，而它可以被用于全局/局部/某个结构体的属性。所以，如果附带上函数调用，就会出现编译错误！所以，初始化宏要只包含变量的声明和初始化，最好不要嵌入函数。
2，变量存储空间的问题：
   1，如果存储为全局变量，那么，声明语句可以作为宏。
   2，如果存储的是某个结构体的属性，通过保存机构体而保持数据，那么，变量的声明就已经在结构体成员里了，这时，不能调用含变量声明的宏。要初始化，必须通过传递值到接口函数进行初始化！而不能使用宏声明！
3，编写接口的时候，先根据使用的环境，再设计接口。（环境是必要条件，接口是可变的，任何违背了环境的接口都是失败的设计）




