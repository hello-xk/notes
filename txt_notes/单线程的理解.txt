单线程的理解。

单线程最直观的理解是，在修改一个全局变量的时候，在修改任意一个变量的时候，不用考虑，在这里访问的同时，是否可能在别的地方被修改了。
单线程是可以肯定，别的地方不可能修改到。因为，执行位置已经到了这个函数内部了，别的地方不可能有同时执行，这就是单线程。
多线程才需要考虑，因为多线程的时候，在这个函数里执行的时候，别的函数可能被另一个线程执行，然后修改当前也要修改的变量。所以，多线程需要才需要考虑。


单线程里的select和poll实现的并发。
感觉select和poll实现的时候，很像多线程，但是，仅仅是像而已，它始终是一个一个执行。
所以，要注意：
1，不要使用阻塞，否则当其中一个并发执行到阻塞的时候，线程就执行到该位置，整个程序就停着等待。
2，并发的逻辑不要太复杂。同样的道理，如果一个并发的逻辑很复杂，甚至加了大量sleep，那么执行这个并发的时候就很花时间，这会影响接下来所有的并发的响应时间。接下来那些并发将迟迟不能被执行。
3，IO多，逻辑简单的可以选用select和poll实现，如500次/秒的并发量。因为IO并不影响单并发的逻辑时间，故可以处理多并发量而不会影响并发响应时间。

举一个单线程执行顺序的例子：
现在有一个cache，里面的数据是用来发送的，逻辑是，先将数据放入cache，再取N个，发送成功后，要移除cache中正在发送的N个数据。
1，判断当前是否正在发送，是，先关闭连接，保护cache不再被修改。
2，将数据放入cache
3，取出N个cache
4，建立新连接和发送

先将数据放入cache和先关闭连接，保护cache有没有先后顺序要求呢？
1，如果是单线程，是没有的。先关闭连接和先将数据放入cache都一样。因为单线程时，程序执行到这里的时候，就是只有这里在执行，别的地方没有被执行。所以，根本没有机会说，不先关闭连接的话，发送那边成功了，不就把cache破坏了。注意，单线程就是说，执行到这里，整个程序就只有这里在执行，所以，你先把数据放入cache，然后关闭连接，再取出N个，建立新连接发送（2134）和你先把数据放入cache，再取出N个，再关闭连接，再建立新连接发送（2314）和你先关闭连接，再将数据放入cache，再取出N个，发送（1234）是完全一样的！
   1，2，3，这三个步骤，不存在业务逻辑上的先后顺序，在单线程里，它们的顺序没有要求，因为进入到这里的时候，别的任何地方已经停止执行，只有这里在执行。单线程里就只有业务顺序，如，总要先取出N个数据才发送的，要不发送什么呢。
   
2，如果是多线程，这是有要求的。1，2，3，4这四个步骤得按1234来执行。这是因为，1234可能同时被执行。即，你在将数据放入cache的时候，发送可能也同时在进行，所以，你不先关闭连接，就修改cache，那么别的线程刚好发送成功，移除了发送成功的数据，cache就被修改了。所以，多线程的时候，首先必须先关闭其它线程的连接，保证cache不被修改，然后才将数据放入cache，然后再取出N个，然后从新建立连接，发送。

以上就是单线程和多线程的区别。
