头文件作用：
1，头文件里的函数声明不是暴露函数的地方。在头文件里的函数声明可以没有，其它文件里仍旧可以访问到该头文件对应的c文件里的函数。所以，头文件里的函数声明只是方便查看该c文件里有哪些函数。
但是，如果调用的函数没有在头文件中声明，则可能会出现  warning implicit declaration of function。警告：隐式声明。原因是，使用了其他文件里的函数，但是该函数没有声明。函数没有声明可能会出现错误：即函数的定义在调用后面！

总之，函数隐藏不能通过头文件的声明实现，只能在函数前面加static关键字缩小函数的作用域。


但是，结构体隐藏则可以通过头文件的声明实现。
2，头文件里的结构体声明，如果不具有结构体成员，则其他文件无法访问该结构体。如：struct book; 这样后包括：sizeof(*结构体指针)，sizeof(struct 结构体)，结构体.成员，结构体指针->成员。这些操作在其他文件里是无法通过编译的，只能在该头文件对应的c文件里访问。
那么如何操作该结构体呢？
c文件里含有结构体的定义，里面有其具体成员，外部文件通过调用该文件提供的方法接口对结构体进行操作。该结构体对外是透明的，不可见的。
这种做法类似封装和隐藏。

下面的情况没有测试：
头文件

首先说下头文件，其实头文件对计算机而言没什么作用，她只是在预编译时在#include的地方展开一下，没别的意义了，其实头文件主要是给别人看的。

我做过一个实验，将头文件的后缀改成xxx.txt，然后在引用该头文件的地方用

#include"xxx.txt"

编译，链接都很顺利的过去了，由此可知，头文件仅仅为阅读代码作用，没其他的作用了！

不管是C还是C++，你把你的函数，变量或者结构体，类啥的放在你的.c或者.cpp文件里。然后编译成lib,dll,obj,.o等等，然后别人用的时候 最基本的gcc hisfile.cpp yourfile.o|obj|dll|lib 等等。
但对于我们程序员而言，他们怎么知道你的lib,dll...里面到底有什么东西？要看你的头文件。你的头文件就是对用户的说明。函数，参数，各种各样的接口的说明。
    那既然是说明，那么头文件里面放的自然就是关于函数，变量，类的“声明”了。记着，是“声明”，不是“定义”。
那么，我假设大家知道声明和定义的区别。所以，最好不要傻嘻嘻的在头文件里定义什么东西。比如全局变量：
/*xx头文件*/
#ifndef _XX_头文件.H
#define _XX_头文件.H
int A;
#endif

那么，很糟糕的是，这里的int A是个全局变量的定义，所以如果这个头文件被多次引用的话，你的A会被重复定义
显然语法上错了。只不过有了这个#ifndef的条件编译，所以能保证你的头文件只被引用一次，不过也许还是会岔子，但若多个c文件包含这个头文件时还是会出错的，因为宏名有效范围仅限于本c源文件，所以在这多个c文件编译时是不会出错的，但在链接时就会报错，说你多处定义了同一个变量，

Linking...
incl2.obj : error LNK2005: "int glb" (?glb@@3HA) already defined in incl1.obj
Debug/incl.exe : fatal error LNK1169: one or more multiply defined symbols found

注意！！！

extern

这个关键字真的比较可恶，在声明的时候，这个extern居然可以被省略，所以会让你搞不清楚到底是声明还是定义，下面分变量和函数两类来说：

（1）变量

尤其是对于变量来说。
extern int a;//声明一个全局变量a
int a; //定义一个全局变量a

extern int a =0 ;//定义一个全局变量a 并给初值。
int a =0;//定义一个全局变量a,并给初值，

第四个 等于 第 三个，都是定义一个可以被外部使用的全局变量，并给初值。
糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是extern int a=0;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次。

当你要引用一个全局变量的时候，你就要声明，extern int a;这时候extern不能省略，因为省略了，就变成int a;这是一个定义，不是声明。
（2）函数
     函数，函数，对于函数也一样，也是定义和声明，定义的时候用extern，说明这个函数是可以被外部引用的，声明的时候用extern说明这是一个声明。 但由于函数的定义和声明是有区别的，定义函数要有函数体，声明函数没有函数体，所以函数定义和声明时都可以将extern省略掉，反正其他文件也是知道这个函数是在其他地方定义的，所以不加extern也行。两者如此不同，所以省略了extern也不会有问题。
    比如：
/*某cpp文件*/
int fun(void)
{
return 0;
}

很好，我们定义了一个全局函数
/*另一cpp文件*/
int fun(void);
我们对它做了个声明，然后后面就可以用了
加不加extern都一样
我们也可以把对fun的声明 放在一个头文件里，最后变成这样
/*fun.h*/
int fun(void);//函数声明，所以省略了extern，完整些是extern int fun(void);
/*对应的fun.cpp文件*/
int fun(void)
{
return 0;
}//一个完整的全局函数定义，因为有函数体，extern同样被省略了。
然后，一个客户，一个要使用你的fun的客户，把这个头文件包含进去，ok，一个全局的声明。没有问题。
但是，对应的，如果是这个客户要使用全局变量，那么要extern 某某变量；不然就成了定义了。

三， 如果在头文件里定义函数。
    在头文件里定义函数，编译器会有warning： define but not used。
解决方法：
    1，定义在头文件里的函数，都加inline。
    2，将头文件里的函数，移到对应的c文件里。
    
总结下：

对变量而言，如果你想在本源文件中使用另一个源文件的变量，就需要在使用前用extern声明该变量，或者在头文件中用extern声明该变量；

对函数而言，如果你想在本源文件中使用另一个源文件的函数，就需要在使用前用声明该变量，声明函数加不加extern都没关系，所以在头文件中函数可以不用加extern。

