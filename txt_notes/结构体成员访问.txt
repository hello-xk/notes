结构体成员访问:
struct book *book;
book->name 相当于 (*book).name 这与name是不是指针无关。

name是不是指针与下一步访问name相关。
如name是指针，则 *((*book).name)	取得指针的值。而字符串的话，可以直接处理指针，所以不用*,只是(*book).name

如果obj是book里的一个结构体指针，obj有成员obj_name则
*((*book).obj).obj_name 等价于 book->obj->obj_name


结构体作为参数时，要修改结构体成员，需要传入结构体指针，而不是结构体变量！ 复合类型的处理，指针的处理等，和普通类型变量一致！！
所以，要通过参数修改结构体，需要传递结构体指针，即结构体的地址。
 
给出一个结构体，如何访问其成员。

typedef struct {
	char *name;				//name可能是字符指针，也可能是字符串！！
	struct {
		char *name;			
		int  value;
	} * values;				//values可能是结构体指针，也可能是结构体数组！！
} u;

1，成员是指针时有多种可能！不同情况有不同的访问！！
	当pu是一个结构体指针时,其他name，values是指针，数组等不同情况时的访问形式：
	1，指针			pu->name;	pu->values;		pu->values->name;   pu->values.value;
	2，数组			pu.name[x];	pu.values[x];	pu.values[x].name[x];	pu.values[x].value;
	3，字符串		pu.name;	pu.values[x];	pu.values[x].name;		pu.values[x].value;

总结：

	结构体里面的指针，关键看什么类型，当是数组，字符串时，我们需要访问的是它的地址空间，而不是值。所以，不是用->，而是用 . 。
	即，点(.)是表示访问内存空间。	数组，字符串是通过访问内存空间，而不是值。甚至，int，long等也是一个内存空间！所以也是用点(.)。到这里又要提醒自己，C语言里面的类型都是一块内存空间。访问该类型的变量，是使用内存空间访问。
		->  是表示访问内存空间里的值。指针指向才需要内存空间里的值。

其实，C语言里对点(.)和->的区别是：
	点(.)是直接寻址。即访问的就是那块内存。
	->是间接寻址。即访问的是存储在那块内存里的值代表的那块内存。

归跟到底都是访问内存。只是访问的方式不同。所以我个人总结的有点离谱了，只是个人方便记忆，方便区分。

重点：
	就是访问一个结构体里面的char *name,如果是字符串，使用的是点(.)。如果访问是的数组，使用的是点(*)，但是数组的表示可以用指针来表示！
总之就是访问地址就是了。
