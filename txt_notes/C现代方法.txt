 以前从没注意过的问题：
 注： 
 1， data = (void *)1;
     int a = (intptr_t)data;
     个人理解：intptr_t是将一个void *指针的值转换为数值。 void *并不能确定长度，因此它可能与实现相关。这些类型主要用于void *与int，long等数值的转换。因为，一些编译器并不确保数值转成指针后转回来数值不变！intptr_t类型说明是，/* Types for `void *' pointers. */，指这个是用于void *类型的，个人认为是用于提供数值与void *间的无损转换。相关类型有intptr_t, uintptr_t，一个表有符号，一个表无符号。个人认为就是将void *指针与有符号和无符号转换，因为这个转换是与系统相关的，故系统提供这些函数。
     
 1，一个简单的size_t * warning也能引发段错误！ 曾经就是因为没有将size_t *与unsigned int*进行转换的wangning，而导致段错误！其实是一个warning造成的。 expected ‘size_t *’ but argument is of type ‘unsigned int *’ 这句造成的不可思议的段错误： 放在子函数里会出现段错误，而抽离子函数，inline到调用处却正常，这是因为参数不匹配，unsigned int *与size_t *指针的强制转换导致的，将参数统一为unsigned int *就没有问题了！！（不可预料的错误）
 2， 在逗号语句中声明的变量类型必须相同。类型不同必须分语句声明！
 3， 宏里面的do...while(0)//没有逗号，里面声明的变量只能用于循环内！if语句也一样属于块！
 4， scanf读入unsigned short,unsigned char时，不是%u，而是%hu,%hhu (h可以理解为half，或者是short)。%h(等价于%hu吧)，读入float和double和long double是不同的，%f和%lf和Lf。读入的话，格式长度不一致，会导致读入错误，比如读入的%f和%lf的结果可能不一致，因为精度不同，字节长度也可能不同。
    h           用于输入短整型数据(可用%hd, %ho, %hx, %hu ) 
    l           用于输入长整型数据(可用%ld,%lo,%lx)以及double型数据(用%lf或%le)
    scanf格式还能是正则表达式！！
    sscanf是从一个字符串作为输入，读入到变量里。返回值是读取了多少个。
    
 5，宏参数是指针的问题：
  #define list_for_each_entry(pos, head, member)                   \
     for (pos = list_entry((head)->next, typeof(*pos), member);    \
  当宏的参数是指针时，需要给参数加圆括号！ 因为如果传入栈的地址，即head = &list那么原想要的效果是(&list)->next 但是因为优先级的问题，变成了 &(list->next)，所以，宏参数是指针时，需要给指针参数加圆括号，因为取址运算的优先级最低。 

重点： 现在有一块已开辟的空间，你要存储一个字符串数组和一个book结构体数组，那么如何做？
    字符串： char **strs;   strs = (char **)buffer;
    结构体: struct book *books;   books = (struct book *)buffer;
    问题： 为什么一个用指针的指针，一个用结构体指针呢？
    解答：   整型是int，那么整型数组是int *;
            字符串是char *, 那么字符串数组是 char **;  （其实，你当其是char *强制使用，其实也没有问题的，都是一个指针值）
            结构体是struct book，那么结构体数组是 struct book *;
            因此，上面可以理解了吧。
    注： 如果这是一个属性，则只能是使用struct book *这种形式，而不能是struct book[];
    当且仅当在形参中，struct book[]才与struct book *等价。其他情况则有可能编译出错！ 
    作为属性：
    struct {                    struct {
        struct book[];  并不等价    struct book *;  强烈建议使用后者！
    }                           } 
   其实很容易理解的：
    str[1] = 整型int，那么，数组是int *;
    str[1] = 字符串char*，那么，数组是char **;
    str[1] = 结构体struct book，那么，数组就是struct book*;

时刻注意的问题：
1，今天又忘记了，一直奇怪下面的语句传入一个指针变量后访问时为什么会出现段错误，明明是得到一个地址值。
    bool gitone_cache_peek_nth(struct gitone_cache *cache, int index, union gitone_cache_data *data) {
    data = &(cache->nodes[(cache->front + index) % QUEUE_LEN].data);
   问题是，你要得到一个地址值，传入的必须是地址变量的地址。换句话，要传入指针的地址。
   总之，记住，要通过参数传地址出来，必须是指针的指针。（当然，虽然参数是指针，你也可以将一个指针的指针强制传递进来，这样也可以修改。但是一般不会这样做！）

2，今天遇到一个同样是指针传递到参数里面的问题。
    char buf[10]; reset(buf, sizeof(buf));
    reset(char *buf, int buf_size) {
        memset(&buf, 0, buf_size);
    }
    这里为什么出现段错误呢？
    又忘记了，指针只是一个副本！函数内的buf只是buf[10]的首地址的副本，你可以逐个赋值形式将该段内存初始化为0.但是，你使用的memset(&buf)得到的是局部变量buf的地址。它的空间就只有4个字节（或8个字节，空间长度==一个指针变量的长度）。你使用的memset(&buf, 0, 10)不仅越界访问，而且将buf局部变量设置为0是没有意义的。
    不知道这样可以不可以: memset(buf, 0, buf_size); 因为buf就是该段内存的首地址了，不用取址操作。
    没错！ 上面的修复方案可行，只是，别人看到memset(buf)，这种用法会很怪异。
    另一个修复方案是，传入指针的指针。不过，reset(&buf, sizeof(buf));这样也很怪异。buf本身就是那段空间的首地址，再取址是什么？这里呢，其实就想函数指针一样，函数名func和&func都是指函数指针。这里也一样，buf和&buf都是指数组首地址。换句话，那么在函数内，仍旧是memset(buf)。
    所以，归跟到底，还只有memset(buf)这唯一的做法。

3，上面2的两种方案产生的细节问题。
    貌似上面两种，参数为char *buf与char **buf都不影响memset(buf)的执行。因为大家都是指向数组首地址。
    但是，这里有一个细节问题，就是指针类型不一致！
    指针类型最重要的作用就是说明步长。所以，上面的buf + 1，是天壤之别的！ 当是char *buf时，步长是1个字节。当是char **buf时，步长是8字节（void *步长）。所以，参数的一些细微的变化，可能会导致逻辑上的异常。在这里的内存操作就会出现跨了一大块没使用的内存空间。

3，输出一个内存的16进制，出现FFFFFFE0，为什么呢？我想输出E0.
   你是不是用了char？ 这关键是输出的类型。
   printf("%x ", (char)buf[i]); //输出有时是FFFFFFXX，有时是XX，为什么呢？ 
   原因： 中文一般都是AX，左边是AX～FX时，已经是1XXX XXXX，如果你将其看作有符号char，那么，其实这是一个负数。但是输出16进制时，怎么会有正负之分呢？gcc编译的输出结果会将其最高位的1作为符号位，然后输出FFFF FFXX（最后的XX是1XXX XXXX的16进制，前面的FFF只是显示这个是一个负值）。所以，如果是0XXX XXXX的char值，其实是没有前面的FFFFF的。如1A，输出时，其实就是1A，不会有前面的FFFF。所以，这种char输出，如果是0XXX XXXX ～ 1XXX XXXX，输出是XX，没有前面的FFFF，如果是1XXX XXXX ～ FFFF FFFF间的值，则会输出是FFFF FFXX，前面会有多个FFFFF。
   修复：
   printf("%02x ", (unsigned char)buf[i]); //这个显示转换表示把内存看作无符号char，那么，都不会输出前面的FFFFF。
   
   这个输出的问题就是这样。但是其内存仍旧只是XX这个字节而已。
   
4，*pint = value与 pint = &value的区别。
   *pint的值为value与将value的地址赋值给pint指针，效果不是一致的吗？ 是的，效果一致，但是原理不同。
   *pint是指将pint指向的内存的值设置为value，假设 pint = &b;那么相当于 p = value;
   pint = &value是指，pint指向的内存是value的地址，假设 pint = &b;那么相当于 pint = &value, pint不再与b变量有关。
   从行为来说，两者都是赋值。但是，前者是给变量赋值，后者是给指针赋值。细节上有区别：
   1，假设int *pint = NULL; *pint = value; 这样是错误的，因为NULL引用。引发段错误。
   2，假设int *pint = NULL; pint = &value; 这样是正确的，因为这是赋值。
   
5，从上面的4例子，顺便归纳一下引发段错误时可能的情况： 
    1，NULL引用。
    2，内存操作时，目标只是一个指针而不是一段空间。
    3，  

6，不要把类型作为类型来用，而是作为内存空间来用。int是4个空间，char和unsigned char都是1个空间。
   链：
   char a=0xFF; unsinged char b=a; int c=b; double d=c; char e=d; 输出e仍旧是0xFF。这就是无论类型怎样变，内存没有变。
   
7，如果使用强制类型转换，输出的值与想象中不一致，而且，输出的值是递增的，很可能，你输出的是地址，你忘记了使用*。
    所以，如果强制转换了地址，可以用数组的方式访问！ ch[i] === *(ch + i)  忘记了 * 就导致错误！        
=========================================================================================
1，float存储的数值比int大，因为float的数值在内存里存储的形式是科学计数法。
   float的实际数值只是一个近似值。如赋值0.1，实际变量的值为0.0999999999987. 这是舍入造成的误差。

2，为初始化的变量不能引用，但能赋值。

3，C对标识符最大长度没有限制。虽然这样说，但是编译器其实不支持那么长。c89是前6个字符有效。c99是前31个字符有效。

4，C的标识符仅限字母，数字，下划线。不含标点！！

5，GCC以前是GNU C Compiler，现在是GNU Compiler Collection，能够编译c，c++，java，object-c等

6，GNU是指GNU is not Unix

7，-Wall编译器检测到可能的错误时，生成警告。-W除了-Wall外，还需要针对具体情况的额外警告。
   -std=c89，-std=c99使用不同c标准。
   -pedantic 根据c标准的要求生成警告消息，可以避免在程序中使用了非标准特性。

8，main中的exit(0) 和 return 0是一样的。

9，main没有返回值，程序返回一个未初始化的一个不确定的值。

10，编译器是完全删除注释还是用空格替换掉？
	早期是删除，但是会导致a/**/b变为ab而造成歧义，故后期C标准，编译器必须使用一个空格替换每条注释语句。

11，c中的段注释不允许嵌套！	但是可以使用//来进行。

12，float常量，需要加f，默认是用double存储。

13，c不检测printf后面参数个数和格式字符串是否匹配。即使不匹配，它只是输出一个无意义的输出。

14，%i和%d在printf中是无区别的。但在scanf中，%d只匹配10进制。%i则可以匹配8，10，16进制。

15，\t的缩进，与操作系统相关。

16，scanf读入一个整数时： 23foo，则能读到23，foo作为下一次。foo23，没有值被接收，foo23作为下一次，这时，程序会继续执行，如果不做处理，一般会崩溃！
	%d%d录入"4,34"时，只能接收到4，逗号认为一个scanf结束。所以，34留到下一个scanf！！

表达式
1，除%求余运算外，其他都支持浮点数。

2，当/与%运算于负数时：C89，-9/7可以是-1也可以是-2（向上或向下取整问题）； -9%7可能是-2或者5 （不是打印错了，是5！  商-1余-2，商-2余5）（符号问题）
					  C99，-9/7 = -1 ， -9%7 = -2. 即c99和使用习惯一致。
   规则是： 只要确保(a/b)*b + a%b == a即可。C89的也符号这规则。
   C99出现的时候，大多数CPU都对除法的结果向0取整，所以，渐渐的，C99就接近现代的数学运算。

3，c标准总会出现一个词： 由实现定义。  意思是，这个操作和实际平台，实际设备，实际系统决定。这意味着，这部分是与设备相关的，可以根据设备的效率选择实现的方式。但是程序员编写时，最好避免这些依赖于实际定义的行为。对于由实现定义的行为，最好查看对应的文档说明。

4，赋值表达式要求左操作数必须是左值。左值是指存储在计算机内存中的对象，而不是常量或计算结果。

5，i =+ j 是 i = (+j)。

6，计算幂，可以i*i*i，也可以使用pow函数。不过，gcc编译math中的函数时，需要加-pm

7，要使用%作用于float怎么办？可以使用fmod函数。

8，a[i++] += 2 与 a[i++] = a[i++] + 2是不同的。后者i的值会自增2次，无法确定会发生什么。

9，++，--会比i=i+1更快吗？  不会！
   现代的编译器，这些运算符不会使编译后的程序变得更小或更快，继续使用和普及，主要是因为它们的简洁和便利，尤其在p[i++]这种运算上。
   （当然，有的编译器，++会比+1要快。因为++只需访问一次内存，+1需要访问2次。）
10，++，--能用于float吗？可以。只是实际应用中，极少采用自增和自减处理float型变量。

11，++，--何时自增和自减？
    C语言有一个顺序点的概念，并指出，应该在前一个顺序点到下一个顺序点之间对存储的操作数进行更新。
    C语言的顺序点有：表达式语句末尾。在函数调用前。

语句
1，if (i == 0) 与 if (i = 0) 是不同的！

2，判断一个范围的惯用法： 0<=i<n
   范围内：if (0 <= i && i < n) ...
   范围外：if (i < 0 || i >= n) ...  

3，长期缺乏布尔类型的问题在C99中得到解决。
   C99提供_Bool型。所以，在C99中，可以使用_Bool flag;   （_Bool只能存储0/1，赋值非0会被转换为1，换言之，这是一个真正的布尔类型！）其实，_Bool是无符号整型，所以_Bool变量实际上就是整型变量，但和一般的整型不同，_Bool只能存储0或1，往里面存储非0会导致变量的值为1.

   C99也提供了stdbool.h来操作布尔值。包含这个头文件后，就可以使用bool flag; flag = false; flag = true;

   为什么不提供一个更好的名字？ 如bool，boolean等？
   因为现有的C程序中，可能大量存在bool或boolean这些名字。难道_Bool就不会？ 不会！
   C89里规定，以下划线和一个大写字母开头的名字是保留字，程序员不应该使用！

4，gcc -Wall能检测 if (a = j), 要删除警告，可以if ((a = j))

5，switch在default拼写出错的时候，不会提示警告！ 因为认为它可能是一个普通的标号！ 所以注意default是否拼写正确！

6，无限循环的惯用法：  while (1) ...  for ( ; ; ) ...
   传统C程序员比较喜欢for的高效性，因为早期编译器经常强制每次执行while的时候都测试条件1，但是，现代的编译器，在性能上应该没有区别。

7，C99的for循环： for(int i = 0; i < n; i++) { ... }

8，goto语句可以跳转到函数中任何有标号的语句处。C99有一条限制，goto语句不能用于绕过变长数组的声明。（另外，貌似在goto后不能进行声明操作）。
	goto不能绕过变长数组，是因为变长数组还没初始化，goto可能会访问到该数组未定义的空间。（变长数组是b[n]这种形式）
9，空语句： 
   for( ; ; ) ;     //错！ 空语句不能放在for后面。这里的空语句要单独一行。
 与for( ; ; );	//对！ 不是空语句，表示无循环体。
   for( ; ; )
      ;			//对！ 循环体是一个空语句。
 还有另外两种：
   for( ; ; )
      continue;
   for( ; ; ) {
   }

10，下面是一个非常有趣的问题： while (i > 0) {} 写成 while (i) {} 怎样？不是一样么？还更简洁不是吗？
    对！但是，也有缺点，1，易读性不好。2，假若循环开始时，i碰巧为负值，新循环的行为将不同于原版。

11，在while和for转换的时候，在有continue的时候，需要注意的是，for每次continue都会导致n++，当然，你可以不把n++放在for括号里面。而while的continue则只会导致循环继续，而不会导致n++！！

12，goto语句有什么不好？
    goto语句之所以不好，是因为它可以向前向后跳，会使代码难于阅读。但是在Linux下，goto常用于错误跳转。

基本类型
1，C99提供两个额外的标准整数类型： long long int 和 unsigned long long int。
   原因：适应对超大型整数的需求，适应64位处理器。
   
   C99把 short int，int，long int 和 long long int 以及 signed hcar类型称为标准有符号整型。
      把对应的unsigned 和 _Bool类型称为标准无符号整型。
 
   C99中，以LL/ll结尾的整数常量表示long long int型。如果在LL/ll前或后加u/U则表示无符号。

2，溢出：  有符号整数溢出，结果是未定义的。
          无符号整数溢出，结果是有定义的，正确答案是对2^n去模。如对无符号16位数65535+1，则结果是0.

3，读写浮点数： 只能在scanf函数格式里使用l，不能在printf函数格式里使用。printf里使用e，f，g即可用来写float和double类型的值。
			   C99允许，printf函数格式里可以使用%le，%lf，%lg。不过，字母l不起作用。
   读double时，加l，读long double时，加L。写double时，不用l也不用L。

4，C89使用整数类型来统称 整数类型，字符类型，枚举类型。
   C99不使用术语整数类型，而是扩展了整数类型的含义使其包含字符类型和枚举类型。C99的_Bool型是无符号整数类型。即都是整数类型。

5，类型转换。如果将某种类型的值赋值给更狭窄的变量，如果该值在狭窄的变量范围外，将得到无意义的值，或者更糟。
   C99中隐式转换和C89的略有不同，因为C99增加了_Bool,long long类型，扩展的整数类型和复数类型。
   
   隐式类型转换蛮重要的，因为如果不懂这些规则，一些运算会很意外！
   前提，两个操作数都不是浮点类型。
   规则1： 都是有符号/无符号，将低等级的转换为高等级类型，然后运算。
   规则2： 无符号等级>=有符号等级，将有符号转换为无符号，然后运算。（有符号转换为无符号时，值跨越很大！）
   规则3： 有符号类型可以表示无符号类型的所有值，将无符号的转换为有符号的，然后运算。
   
6，新类型的定义：
   1，可以使用#define BOOL XXX		//宏后面没有分号。	XXX 可以为int，long，long long等。
   2，可以使用typedef XXX Bool;	    //类型定义后有分号！
   这两种方式，使用typedef更好，因为它使编译器将其作为新的类型，而不是宏定义。
   这两种方式，在类型的范围改变时，可以轻松改变，只需要改变XXX的类型为long，long long等。

   为什么使用typedef更好呢？
   Pointer a,b,c;   如果Pointer使用宏实现，则是int * a,b,c; 只有a是指针！ 但是如果使用typedef实现，则abc都是指针！！

7，size_t sizeof();
   C89中，size_t一定是无符号整数，所以，可以安全将sizeof的返回值转换为unsigned long然后进行输出： %lu, (unsigned long) sizeof(int);
   C99中，size_t可以比unsigned long更长（long long），但C99提供了直接显示size_t的值。%zu, sizeof(int);
 
   C99中，sizeof是编译器确定的值，sizeof不能确定变长数组的大小，因为它在程序执行期间是可变的。
   sizeof可以计算，数组长度，结构体空间。其实，sizeof就是计算该标记管理的空间的！！

8，什么时候考虑字符变量是有符号的还是无符号的？
   如果变量中只需存储7位的字符，那么不需要考虑有符号还是无符号，因为符号位都将是0.
   如果计划存储8位字符，那么将希望变量是unsigned char类型。
   个人注：如果只是用于处理字符，char和unsigned char是没有区别的。它们在内存中的数据是一致的，只是你怎么看。
   如DB，在内存是1101 1011，你可以用无符号或有符号的char进行存储。它们在内存中始终是1101 1011. 输出到文件，流中，也是一样。所以字符处理，char和unsigned char无区别。
   
   真正有区别的是，你要转换它们成为数值的时候。用char存储1101 1011，转换为数值时，最高位的1是符号位，不算值。用unsigned char存储1101 1011，转换为数值时，和原来数值一致。唯一的区别就是这点而已！！！

9，\r\n是用于使程序与操作系统无关。

10，\?转义目的，是为了区别 xxx ? XXX : XXX。

11，getchar比scanf看，为什么还用scanf录入单个字符？
    scanf更灵活。如" %c"可以读入第一个非空字符。而getchar会直接读取第一个字符。
    另外，scanf可以同时读入不同类型，"%d%c%d".

12，什么情况下，整值提升会把字符，短整数转换为unsigned int类型？
    这主要是因为该平台下，int类型的范围无法容纳所有可能的值，如16位机器上，unsigned short和unsigned int是一样的。所以转换为unsigned int。16位机器上，long才是16位。int和short都是8位。32位机下则是int和long都是32位。当然，看具体情况。

13，超出范围的赋值，结果是如何？
    一般，如果是无符号整值，那么会丢掉超出的位数。如果是有符号，则按照实现定义。如果把浮点数，则因为变量太小而无法承受，出现未定义行为，包括程序终止。

14，局部变量的值是未定义的！ 静态变量才会有默认值（或者是全部置0，这要看编译器怎样处理吧）。
    所以，局部的结构体变量，其成员都是未定义的！不能直接使用，必须先赋值！！

数组：
0, 数组初始化。
    int a[15]; 这叫没有初始化。 则分静态变量和局部变量，分别有不同的值。
    int a[15] = {0}; 这叫初始化。所有元素为0。
    int a[15] = {0, 1}; 这也叫初始化。第一第二个元素指定，其他为0。
    int a[15] = {}; 错误。
    int a[] = {1, 2, 3}; 数组长度是3。
    注：只要有初始化，那么，无论是静态变量还是局部变量，如果有指定值，则为该值，如果没有指定值，都默认是0，这是初始化，并不是指没有初始化的时候。
    struct book { int a, int b, int c};
    struct book b[] = { {1, 2}, {1}, {0}};
    那么，b为b[3]，所有没有指定值的元素，都是0！这个时候是不论静态还是局部变量。

1，C99的指定初始化式： 
     int a[15] = {[14] = 48, [6] = 2, [3] = 2};
     int b[] = {[2] = 1, [23] = 4}; //以最大的初始化为数组长度。所以b长度为24.
     int c[10] = {4,2,1,[4]=4,5,6,[8]=8};  //混合式。
     没有指定值，均赋予默认值0.

2，多维数组初始化： 最好不要省略內层的花括号。
   C99的指定初始化对多维数组也有效。

3，C99的变长数组。
   int n;
   scanf("%d", &n);
   int a[n];
   //这里，a[n]就是变长数组。

   变长数组： int a[3*i+5]; int b[j+k]; 等等。 
   虽然说sizeof不能计算变长数组的长度，但是gcc下，可以得到其长度。(get_size(int a[]){ sizeof(a) };这里得到的是指针，而不是数组！不能计算出数组长度。因为它在函数内，只是一个指针值的副本，所以计算的自然是一个指针占用的空间。sizeof能计算的只是标识符对应的空间。更准确的，是一个栈空间)

   变长数组的使用：  一般不在main函数里使用，而在子函数中。目的是每次进入子函数，数组的空间都可以按实际需求分配。不至于浪费。

4，字符。 字符并不一定都是连续的，这要看字符编码。所以ASCII码是连续的，但是其它则不然。所以。'A'-'a'这类的只对ASCII有效！！

函数
1，函数的形参在声明时可以省略形参变量名。在函数定义（实体）时，函数的形参必须具备变量名！

2，C89中，函数返回值类型省略，默认是int。而C99中，这是错误的！必须具备返回值类型！

3，函数调用需要小括号，小括号丢失，可能有warning，但不会出错。如 print_fun;

4，C89中，变量声明必须出现在语句之前。
   C99中，变量声明和语句可以混合在一起。只需变量在使用之前声明即可。
   C99中，函数调用前不提供声明或定义是错误的。
    注： 在逗号语句中声明的变量类型必须相同。类型不同必须分语句声明！

5，C99中，变长数组的形参。
   一般是: int array(int a[], int len) { ... }
   但是，这时，a和len是没有关联的。
   C99的支持： int array(int len, int a[len]) { .. } 表明，len就是数组的长度。
   注： int len要在a[len]前，因为编译器找到a[len]时，会发现len并没有出现。所以int len要放在前面。

6，数组参数声明中使用static。
   int sum_array(int a[static 3], int n) { ... }
   C99中，这里的static只是一个提示，表示，数组的最小长度是3.这样编译器会有所优化，即会预先取出这些空间的值。
          对于二维数组，只可用于第一维
   C99中，可以这样使用：  sum_array((const int []){2,3,2,4}, 4);  //这样做的好处是，不用创建一个变量存储，节省一个变量。

7，可以用parameter表形参，argument表实参。或者，formal argument，formal parameter 与 real argument，real parameter

8，C不允许函数定义嵌套。即函数体内不能含有函数体。

9，编译器将不含有括号的函数名看成是函数指针！ 就像数组名表示数组首空间的指针一样。

10，函数参数与逗号运算符：
    fun(a, b);  //是参数分割。
    fun((a, b));	//小括号内的逗号被看作是逗号运算符。

11，形式参数的变量名不需要和函数定义中的参数名字相同。

12，函数原型的必要性(声明的必要性)：
    1，两个函数相互调用，则必须要有函数声明，否则总不能通过编译。
    2，大规模程序，使用模块化，需要函数原型来告诉编译器其他文件中定义的函数。

13，double average(); 这种参数不匹配，仍旧可以传递参数的声明形式虽然支持，但是不可取！

14，为什么在函数原型中省略形参变量名？ 1，为了隐藏。2，形参可能和宏相同然后被宏替换（其实不怎么会发生，因为宏一般是全大写，而参数名都应该是全小写）

15，把函数声明放在函数内部，可行？ 合法！
    不过不建议，因为修改函数时会异常麻烦。

16，如果几个函数具有相同的返回类型，是否可以合并声明？ 合法！ 而且还可以和变量声明混合。
    如 void printf_fun(void), printf_count(int n);
	如 int a，b，is_true(void);    
	不过不建议，因为会使程序不易于阅读。

17，函数形参数组指定长度，会如何？ 编译器会忽略长度，仍旧只是指示一个指针。
    int count_sum(int a[3], int b[3]);
    虽然说明它们的长度为3，但其实是没有意义的，不会增加安全性。能起到的作用只是提示。仍旧可以传入任意长度的数组。
    因为形参的这种形式只是表示是一个指针。你甚至可以这样int count_sum(int *a, int *b);效果其实是一致的！

18，数组形参，为什么第一维不需要指定，但其他维必须说明呢？
    因为，数组实参的传递，只是传递数组的第一个元素的地址。如果无法通过元素的值来判断数组结束，还需要传入数组长度的值！
	对于1维数组，得到第一个元素的地址，可以根据元素的类型，一个元素一个元素地遍历下去。所以，除非能通过元素自身判断数组的结束，否则，数组的长度需要传递进来！
	对于2维数组，得到的仍旧是第一个元素的地址。至于要说明第二维的长度，目地在于，可以通过这个第二维的长度，知道数组的下一行的开头！那就是数组首地址 + 第二维长度 = 下一行首地址。 在内存中，2维数组仍只是像一维数组那样存储。
    必须说明第2维的长度，是为了编译器执行a[i][j]时能够定位到该内存位置！没有第2维的长度，编译器不知道开头到哪个位置就要换到下一行。

19，return 0; 可以加括号也可以不加，现在的都不加了。

20，非void返回值的函数，如果只是return而没有值，在C89中，会返回一个未定义的结果。在C99中，不合法，会编译错误！

21，main中不返回值： C89会出现warning，C99则不会出现。C99会自动返回0.（其实gcc下会的）

22，main的返回值为void。C89是非法的，C99是合法的。但是现在的基本都使用int main();然后返回一个值。这样在shell下就可以测试返回值。

程序结构
1，文件内static int g_int = 110;的访问范围。
   现在有2个文件： test_global.c an_other_file.c (前者用于测试是否能访问到an_other_file.c里面的全局变量)
   假如这句全局声明在an_other_file.c里面。则除非包含了an_other_file.c自身，否则不能访问到该全局变量g_int; 因为，没有进行任何关联！
   只有XXX.c的情况下，要访问其全局变量，唯一的做法是，在使用的文件里，include该c文件。
	
   增加一个头文件后： 假如an_other_file.c有其对应的头文件。
   1，如果头文件里什么都没做，那么，只是包含an_other_file.h，仍旧不能访问到该全局变量g_int; 因为，没有声明！
   2，在该头文件里声明。如extern static int g_int; 因为有了声明，所以test能在该头文件里，找到声明，然后找到定义。
   3，在该头文件里定义。不在c文件里定义，而直接在头文件里定义。不过，这种做法，和上面的直接包含c文件自身没有区别！

   //以上在2处，出现错误，为什么呢？  因为static是说明该全局变量作用范围只在文件内。而extern又要修改其范围为全范围。这里很大矛盾！而且，extern static不能搭配。
   问题； 1，如果全局变量有static修饰，表示该全局变量的作用范围为文件内，所以不要想着使用extern来在外面声明并使用，这是错误的！
             正确的做法是，在该文件内，提供一个函数，该函数返回该全局变量的值。就像java里的private属性与get/set方法。
         2，全局变量去掉static修饰，即int g_int = 110。这时，可以在头文件里直接使用extern int g_int声明。
             于是，所有包含该头文件的模块都可以访问该全局变量。这种做法就像public属性。

2，给函数说明时，可以说明函数的作用，函数的副作用： 如修改了外部变量，覆盖了某些策略等等。

3，静态变量与局部变量对递归的影响： 显而易见，静态变量就是每次进入递归都会保持那个值，而局部变量每次进入递归就为新的赋值。

指针
1，不要将间接寻址运算符用于未初始化的指针变量。如int *p;printf("%d", *p);*p=1; 这样是很危险的！ 为初始化的指针，只可以赋值，不可以寻址！

2，不要将一个变量，一个值作为指针来使用！

3，永远不要返回局部变量的指针！

4，指针总是和地址一样吗？ 不是！ 
   旧编译器还有两种指针： 近指针和远指针。地址还有偏移地址，实地址。

5，*运算符。 *运算符有2种含义，1是表示指针类型。2是表示间接寻址运算符。 

6，输出一个变量的地址printf %p ，但是意义不大。

7，const int *p是不能改变p指向的整数的值，而不是说不能改变p指针指向。 
   int * const p才是指针不能改变，但是可以改变指针指向的整数的值！ 这种比较少用，因为一般而言，只需保护指针的指向的空间已经足够。保护指针不可修改意义不大。
   还有一种是两者都保护： const int * const p; p指针自身不能修改，其指向的空间的值也不能修改。

指针和数组
1，如果指针p指向数组元素a[i]，那么p+j指向a[i+j]， p-j指向a[i-j];
   当然，前提是a[i+j]等必须存在。

2，如果p指向a[i]，q指向a[j]，那么 p - q = i - j；

3，指针的加减是建立在指针类型上的，不同类型加减的步数不同。如果指针一开始是未定义的，执行加减结果也是未定义的。
   指针也可以比较。
   指针的操作，一般是在指向同一个数组时结果才有意义。可以得到偏移，间距等等。

4，C不检测数组越界，或者更准确地说，C没有界限，只有内存空间。唯一的检测，是编译器负责的，编译器只负责检测类型的声明和定义是否合法，仅此而已。

5，int *p = (int []){2,3,4,5,6}; 等价于 int *p = a; 等价于 int *p = &a[0]

6，*p++ | *(p++)       自增前表达式的值是*p，以后再p自增，p指针自身递增，其指向的值没有变化。
   (*p)++				自增前表达式的值是*p，以后再*p自增，p指向的值递增，p指针自身没有变化。
   *++p | *(++p)		先p自增，自增后表达式的值是*p，p指针先递增，然后取其指向的值。
   ++*p | ++(*p)        先*p自增，自增后表达式的值是*p，p指向的值递增，p指针自身没有变化。
 
   总结，对值进行自增，(*p)++和++(*p)效果一致！  就像++i 与 i++ 一样。
        对指针递增，有先递增，后取值。和，先取值，后递增。
   先取值，后递增是常用式： *(p++) 或 *p++
   先递增，后取值，是： *(++p) 或 *++p      //将++作为前缀即可。

7，直接用数组名进行加减运算可以吗？ 不可以。因为，数组名是指针常量！
   int a[] = {1,2,3,4};
   a++;	//直接使用数组名是不可以执行加减运算。要进行运算，要先赋值给一个指针。int *p = a; p++; //指针变量才可以。

8，形参中，int a[] 与 int *a 都是指针，占用的空间也就1个指针的空间。 没有区别。

9，将多维数组看作一维数组处理，并不会得到速度的提升。

10，二维数组的指针。  int a[m][n]; int (*p)[n]; 其实p也就是数组指针。
    这是一个变长数组。C99才支持。

11，采用下标与使用指针，哪种更好？ 以前指针访问会更快，现在有些时候，下标反而会更好。所以，可以根据情景，选择合适的，自然的那种。

12，i[a] 与 a[i] 是一样的吗？ 对的！   （这很神奇，第一次接触）
	对于编译器，i[a]等同于*(i + a)，也就是*(a + i)，也就是a[i]。  所以是正确的！
    但是，不要使用i[a]，除非你正在计划参加下一届模糊C代码大赛！

13，形参中 *a 与 a[] 哪种更好？ 根据情况选择吧。有人认为*a告诉我们，传递的是指针副本，而不是数组副本。

14，把二维数组视为一维数组对大多数编译器而言是合法的，但不是所有！
    因为现代有的编译器会进行“越界检查”，会记录数组的长度。

字符串
0，字符串拼接：
   1，使用\,     "abc     \
                 def";         //这种方式，def前面的空格会被记录。
   2，使用两个字符串以空格相隔。
                "abc"
                "def";			//这种方式，字符串是"abcdef"，只要两个字符串相隔空格，换行，就会被编译器自动拼接。是C标准！
1，这里有一种很神奇的用法： 
   char digit_to_hex_char(int digit) {
      return "0123456789ABCDEF"[digit];	
   }
   //这种用法从来没有使用过，但是它很妙。

2，不能修改常量。char *p = "abc"; *p = 'd';  //这个轻则运行不稳定，重则程序崩溃。

3，C语言规定，字符串都要以空字符结束。一说字符串，就默认以空字符结束。且这个空字符是算进空间里的，但不算在字符串长度！

4，C语言一遇到'\0'即认为字符串结束。

5，读入n个字符串，使用scanf("%ns")可以控制，而gets天生就不安全，不可控制。

6，讨论字符串的操作安全性。字符串库函数的操作的安全主要是在内存访问越界上。
   strcpy(dest,src)不会检测dest的空间，很不安全。所以，建议使用strncpy。
   strncpy(dest,src,sizeof(dest));   //注，如果dest是指针，sizeof并不是数组的长度！也是不合理的。
   strncpy(dest,src,strlen(dest));	 //注，这也是不合理的，因为dest中'\0'可以出现在任何位置，strlen并不是它的空间！
   strncpy(dest,src,DEST_LEN);		 //要安全，只能记录dest的长度。
最后，还得加上dest[DEST_LEN-1] = '\0'; 因为strncpy当src很长时会截断而导致dest无'\0'照样导致不安全。所以手动添加结束符能避免错误，更安全！

7，字符串库函数操作中XXX安全性总不及XXXnXXX。当然，后者因为有长度限制，会稍微慢一点，但会安全很多。

8，遍历一个字符串： while(*s++) {...} 和 while(*s){...;s++;}

9，字符串常量可以多长？
   C89，编译器至少支持509个字符。
   C99，编译器至少支持4095个字符。

10，为什么不把字符串字面值称为“字符串常量”？
    因为它们并不一定是常量，只是，一般而言，都是将字符串字面值放在程序的只读段，所以才无法修改!

11，char *p = "abc"; 无法修改"abc"的值，因为它们在“只读”区域！！

12，使用strlen和strcat等是否是使用C那样编写？
    有可能，但是，编译器提供商一般用汇编代替C来编写这些函数。用汇编编写这些函数能够获得很高的效率。

预处理器
1，预处理器是一个小程序，用于处理C文件里的#define，#include等指令。

2，#include是将对应文件的内容，添加到当前的C文件，合并成一个新的文件。当然，现在的预处理器可能不会这样做了！

3，#define MAX(x,y) //MAX与(之间不能有空格！，否则它是一个简单宏，而不是现在的带参数宏。宏就两种，简单宏与带参数宏。

4，宏可能导致的问题： 
   累加。
   n = MAX(i++, j) 会变成 n = (i++) > (j) ? (i++) : (j) 从而导致累加错误！！
   编译后代码变大。没有类型检查。不能使用指针指向。

5，宏参数是指针的问题：
  #define list_for_each_entry(pos, head, member)                   \
     for (pos = list_entry((head)->next, typeof(*pos), member);    \
  当宏的参数是指针时，需要给参数加圆括号！ 因为如果传入栈的地址，即head = &list那么原想要的效果是(&list)->next 但是因为优先级的问题，变成了 &(list->next)，所以，宏参数是指针时，需要给指针参数加圆括号，因为取址运算的优先级最低。 

5，#与##运算符。这两个运算符是预处理器执行的，而不是编译器。 这两个运算符很神奇！！
   #运算符是将宏的一个参数转换为字符串字面量。  宏的参数！    即是参数宏里面的参数！  是将参数直接作为字符串！！不用运算！！
   如，#define PRINT(n) printf(#n " = %d\n", n);
        PRINT(i/j) 将等于 printf("i/j"" = %d\n", n); 等价于 printf("i/j = %d\n", n);   //字符串是"i/j"，而不是它的表达式结果！
 
   ##运算符是将两个记号（如标识符）粘合到一起，成为一个新的记号。  
   如，#define MK_ID(n) i##n
        int MK_ID(1),MK_ID(2),MK_ID(3)就变为了 int i1，i2，i3;
       #define FLAG(n) n##FLAG
        FLAG(READ),FLAG(WRITE)就变为了READFLAG，WRITEFLAG
	   #define GENERIC_MAX(type) \
                type type##_max(type x, type y) \
				{								\
					return x > y ? x : y;		\
				}

    应用： 枚举的FLAG 对应 字符串
    简单法：
	  enum device_flag {		// 也可以 typedef enum { .. } device_flag;
         DEVICE_NORMAL,
		 DEVICE_GPIO,
         DEVICE_FILE,
         DEVICE_IIC,		//   C99,这里的逗号可有可无！！
      };
	  #define DEVICE_FLAG_TO_STRING(flag) #flag

	  这样，DEVICE_FLAG_TO_STRING(DEVICE_NORMAL) 就变为 "DEVICE_NORMAL"字符串
      但是，string_to_device_flag就比较麻烦。

    复杂法：
枚举：
 #define DEFINE_FLAG(flag) DEVICE_##flag,		//拼凑 标识符
 typedef enum DeviceType {
     DEVICE_TYPE_LIST(DEFINE_FLAG)
     _DEVICE_TYPE_MAX,
     _DEVICE_TYPE_INVALID = -1
 } DeviceType;
 #undef DEFINE_FLAG

	  #define FLAG_NAME(flag)    #flag,				//注，这里的逗号不是逗号语句！ 而是宏里的一部分！ 其实，逗号可以放在下面。放在这里只是为了隐藏。
	  static const char * _DEVICE_TYPE_NAMES[] = {
		   DEVICE_TYPE_LIST(FLAG_NAME)
	  };
	  #undef FLAG_NAME

	  #define DEVICE_TYPE_LIST(n) \			//传入的参数也是一个宏。 FLAG_NAME
              n(NORMAL)	\					//其实，就变成了FLAG_NAME(NORMAL), 也就变成了 "NORMAL", 逗号是宏的作用。
              n(GPIO)	\					//其实，就变成了FLAG_NAME(GPIO), 也就变成了 "GPIO",      
              n(FILE)	\
			  n(IIC)	\					//其实，逗号可以放在这里： n(IIC), \
          
于是，_DEVICE_TYPE_NAMES[] = {
		"NORMAL",
        "GPIO",
	    "FILE",
        "IIC",
	 }

所以，对于字符串转枚举类型，就有了
     enum device_flag string_to_device_flag(string)
     for (i = 0; i < DEVICE_MAX, i++) {
     	if (strcasecmp(_DEVICE_TYPE_NAMES[i], string) == 0) {
			return i;
        }
     }
     return _DEVICE_TYPE_INVALID;


思路：
	主要是利用参数进行分发。
	#define DEVICE_LIST(n) n(NORMAL),n(GPIO),n(IIC)		//DEVICE_LIST是入口，通过参数指配一个函数。 
    所以，n是 printf，则变为printf(NORMAL),printf(GPIO),printf(IIC);
		 n是 FLAG_NAME,则变为宏 FLAG_NAME(NORMAL),FLAG_NAME(GPIO),FLAG_NAME(IIC) 
    若#define FLAG_NAME(n) DEVICE_##n##_FLAG  则变为 DEVICE_NORMAL_FLAG,DEVICE_GPIO_FLAG
    若#define FLAG_NAME(n) #n#_FLAG 则变为"NORMAL_FLAG","GPIO_FLAG"
    若#define FLAG_NAME(n) n(NORMAL),n(GPIO),n(IIC) 则又会变为 NORMAL(NORMAL),GPIO(GPIO)...

逆推：
	一般而言，先写出目标格式。
    然后，根据目标格式相同的部分，抽离成为一个宏。
    如果宏还具有相同部分，还可以再抽离成为另一个宏。
    如果另一个宏还有相同部分，还可以再抽离...
    以此类推。

6，宏生命期和作用域从定义开始到文件结束。

7，宏里的参数最好都加上小括号。

8，较长的，含有语句的，最好加 do { ... } while (0)		//没有分号！
   为了使宏和普通语句一样不产生歧义，且无论何时都可以作为语句使用，最好加do .. while(0)   //没有分号！
   这主要防范了多句多段的宏在没有大括号的if/else中截断了if/else的语法，导致错误。
   注： 如果使用宏定义变量，那么，不能嵌入do { ... } while (0) 内，这是因为，在循环或条件语句内声明的变量都被作为块变量！！出了宏就无效。所以，如果要使用宏来一次性定义一系列相关的变量，那么不能嵌入在do...while里。嵌入在do...while里的变量只能在循环里使用。
    
    这是为了防止 if () 宏  else ... 宏若有多个语句，会断掉if..else语句。 所以，如果if...else...总有小括号，那其实是没有问题的。
    
    为了解决上面的问题，除了do...while(0)外，因为do...while包含声明语句只能用于循环内部，故可以将宏定义为 逗号语句，而不是多语句。
    #define init() XXX,XXX,XXX      
    
9，C99，支持空的宏参数： 有参数，但调用时没有传递参数。
   C99，支持可变参数宏。虽然可变参数函数早已提供，但是可变宏则在C99提供。可变参数宏，仍旧使用...表示其余参数。__VA_ARGS__表示实际的多出的参数。
   #define TEST(condition, ...)  \
           ((condition) ? printf("Passed test:\%s\n", #condition) : \
           printf(__VA_ARGS__));

10，条件编译： #if ... #endif
    当预处理器遇到#if指令时，会计算常量表达式的值。如果表达式的值为0，那么#if与#endif之间的行将在预处理过程中从程序中删除；否则#if和#endif之间的行会被保留在程序中，继续留给编译器处理--这时的#if和#endif对程序没有任何影响。
    注： #if会把没有定义过的标识符当作是值为0的宏对待。因此#if XXX会失败！
    另外，XXX()的标识符为XXX，所以，#if XXX 就可以了。

11，defined(XXX)当XXX被定义过，返回1，否则，返回0。    #if defined DEBUG ... #define DEBUG

12，#ifdef XXX ... #endif    
    #ifndef XXX ... #endif
    #if !defined(XXX) ... #endif

13，#if / #ifdef / #ifndef 表达式 
    ...
    #elif 表达式
	...
    #elif 表达式
    ...
    #else 
    ...
    #endif

14，条件编译作用：1，编写多台机器，多系统可移植的程序；2，编写多编译器编译的程序；3，为宏提供默认定义；4，临时屏蔽包涵段注释的代码。
    1，#if defined(WIN32) ... #elif defined(MAC_OS) ... #elif defined(LINUX) ... #endif
    2，#if __STDC__ ... #else ... #endif
    3，#ifndef BUFFER_SIZE #define BUFFER_SIZE 256 #endif
    4, #if 0 ....  #endif         //中间包含的是要临时注释掉的段。可以避免嵌入的/**/的限制！
    5，#ifndef __HEADER_H__  #define __HEADER_H__  ...头文件内容...  #endif

15， #error通常用于检测正常编译过程中不应该出现的情况。遇到#error预处理会显示一条包含消息的出错信息，出错后，不同编译器会有不同的处理，有的会直接中断编译。
     #if INT_MAX < 100000
     #error int type is too small
     #endif

     #if defined(WIN32)
     ...
     #else
     #error Not win32 platform
     #endif

16，#line用于改变程序行编号，不常用。 
    #line n
    #line n "文件"

17，#pragma要求编译器执行某些特殊操作提供一种方法。这个指令对大型程序或需要编译器的特殊功能的程序非常有用。
    #pragma 记号。
    1，#pragma data(heap_size => 1000, stack_size => 2000)
    编译器不会对#pragma中无法识别的命令给出出错信息！编译器不允许这样做。
    C99有_Pragma运算符
    1，_Pragma("data(heap_size => 1000, stack_size => 2000)")

    _Pragma是运算符而不是指令，所以它可以出现在宏定义中。
    
    #define DO_PRAGMA(x) _Pragma (#x) 

18，一些程序中#独占一行，合法吗？ 合法，是空指令。用于间隔。
    #if INT_MAX < 10000
    #
    #error int type is too small 	//字符串不需要加引号。
    #
    #endif

19，宏可以定义为 标识符，字符串值，字符值，字面值，等等非常丰富的内容。因为它只是简单替换。

19，哪些常量可以定义为宏？ 
    1，除0，1外的每一个数值常量都应该定义为宏。字符串常量则是，
    1，字符串常量不止一次被使用。
    2，字符串常量日后可能要修改。根据这条规则，我不会这样使用宏： #define NUL '\0'，大概因为基本不会被修改。

20，宏的字符串化： 
    #define TOSTRING(s) #s
    TOSTRING(abc) => "abc"
    TOSTRING("abc") => "\"abc\"" 	//即本身含有“”双引号。
    TOSTRING(C:\abc) => "C:\\abc"

21，#define CONCAT(x,y) x##y
    并不能将CONCAT(a, CONCAT(b,c))变为abc。而是aCONCAT(b,c)因为没有aCONCAT宏。 //含有##的不能嵌套调用。
    所以，可以这样：
    #define CONCAT2(x,y) CONCAT(x,y)
    CONCAT2(a, CONCAT2(b, c)) 就可以得到我们想要的结果。貌似是一样的，只是，含有##的不能作为嵌套调用。必须用CONCAT2间接调用它，然后用CONCAT2作为嵌套体。
    同理：
    #define N (10)
    #define TOSTRING(n) #n
    TOSTRING(N)得到的是"N"		//含有#的也不能嵌套调用。
    改为：
    #define N_TOSTRING(n) TOSTRING(n)
	N_TOSTRING(N) 得到的才是 "10"

22，宏会导致无限循环吗？ 旧的编译器可能会，现代根据C标准，如果宏在扩展过程遇到重复宏，将不会再次展开宏。
    #define N (2*M)
    #define M (N+1)
    i = N;          // i = (2 * (N + 1))

    一个大胆的做法：
    #undef sqrt		//假设已经被预定义，这是保险做法
    #define sqrt(x) ((x)>0 ? sqrt(x) : 0)		//截获库函数的sqrt(x)调用。使用自定义返回值。宏里面的sqrt(x)不会被展开，于是就成为库函数的sqrt。

23，既然有#if或defined等，为何还提供#ifdef和#ifndef
    因为先出现#ifdef和#ifndef，defined是后面增加的，增加多条件判断的支持： #if defined(FOO) && defined(BAR) && !defined(BAZ)

24，不是说#if 0 ... #endif 会屏蔽掉那部分吗，为什么还会屏蔽的代码中还有错误？ 
    这不是简单的屏蔽，而是要求所有代码已经完整： 注释开关完整，代码语法完整。这样上面的屏蔽才能有效。

编写大型程序
1，#include "/lib/utils.h" 或者，在gcc编译时，将库的路径加到编译选项里。gcc XXX -I ./lib

2，一般而言，一个c文件对应着它的头文件，并且包含它的头文件。这是为了使得编译器验证 函数原型 和 函数定义。

3，保护头文件 #ifndef _HEADER_H_ #define _HEADER_H_ .... #endif

4，#ifndef __STDC__
   #error This header requires a Standard C compliler
   #endif
   用于最初的C89标准不存在的特性时，提示错误。即，此文件要求C89以后的标准。

5，在程序外定义宏： gcc -DDEBUG=1 foo.c

6，#include .c 和 .h的区别。
   其实，即使.c文件里也做了包含保护，和头文件还是有区别的！
   假如： 两个c文件都含有同一个函数，则如果同时包含这两个文件，就会出现问题。
          而如果两个头文件里包含同一个函数，可以轻松在其中一个头文件里删除一个即可。
   而且，头文件可以作为接口，保护c文件私有的函数。

7，只使用一个头文件不好么？ 虽然说好管理，但是，大型程序不合适。
   1，不能提供可读信息
   2，依赖于同一个头文件，修改源文件可能全部都需要重新编译。

8，如果源文件包含了不需要的头文件，会有损害吗？ 不会，最多是编译时间长一点。

9，如果程序调用stdio.h中的函数，是否意味着stdio.h中的所有的函数都将和程序链接呢？ 不是。
   包含头文件对链接没有任何影响，在任何情况下，大多数编译器只会链接程序实际需要的函数。

10，编译和链接是完全独立的！ 头文件只是为了给编译器而不是给链接器提供信息！

结构，联合和枚举
0，复合类型变量和普通类型变量一样，如果要通过参数进行修改，需要传入指针。即复合类型变量的地址。
   需要记住的是，C语言里，变量都一样，要通过参数进行修改，必须传入该变量的地址。变量的范围包括： 普通变量，指针变量，结构体变量，其他变量。
	比如： struct book[10]; 可以通过book[2] = book[1]来赋值。 无论book内嵌多少个结构体，都是可行的，不用怀疑！如果出错，说明是逻辑错，而不是这里不能赋值！
	只是，struct book1[10]; struct book2[10]; 不可以book1 = book2；因为这是数组！

1，C99，对结构体初始化不要求所有成员，剩余的成员都用0作为它的初始值。特别地，剩余的字符数组中的字节数是0，表示空字符串。

2，C99，可以用点指示符来对成员进行赋值。 {.number = 528, .name = "Disk drive", .onhand = 10}

3，结构体，联合和枚举都以 大括号+分号( {XX;XX;xx;}; ) 结束。 其中成员，结构体使用分号分隔，枚举和联合使用逗号分隔。

4，sizeof(结构体)可能大于结构体的大小，这是因为字节对齐问题。

5，不能用==来比较结构体。当然，字符串也一样。

6，结构体的标记名和typedef的名是否可以一样？ 可以！

7，如果两个文件都含有part结构体的变量，这两个变量是否一样？ 技术上说，是不一样的！
   C标准说，一个文件中的part类型变量所具有的类型和另一个文件中的part类型变量所具有的类型是兼容的，那么，这些兼容变量可以相互赋值。
   C89中，成员顺序相同是兼容的。
   C99中，只要标记相同，那么是兼容的。

8，一些结构体，联合和枚举中，最后一个成员还含有分号或逗号，这是合法的吗？ 在C89和C99中，是合法的！

9，枚举类型的值可以作为下标吗？ 可以！
   [MONDAY] = "monday", ...//枚举值也是数值，所以是理想的下标。

指针的高级应用
1，if(p == NULL) if(p != NULL) 本书倾向于这种显式比较。隐式比较难以发现错误！

2，当使用malloc为字符串分配内存时，不要忘记包含空字符的空间。

3，像concat这样动态分配存储空间的函数必须小心使用。当不再需要时，需要free掉返回的字符串。类似的还有asprintf();

4，使用动态分配函数时，建议使用sizeof(类型) * size作为空间长度，可以避免在不同平台上类型长度的错误。

5，使用动态分配函数分配到的空间，是不可以使用sizeof运算符计算其空间大小。要记住，sizeof只能计算标识符占用的栈空间的长度。换句话，sizeof里面的标识符在栈占用的长度就是其返回值。因此，动态分配函数最终存储在一个栈指针，故其sizeof其实就是一个指针的长度。

6，传递给realloc函数的指针需要来自先前的malloc，calloc或realloc的调用，但其实不一定的，因为realloc是一个行为非常复杂的函数，会根据参数的值有不同的行为，包括有malloc或free的行为！当然，不建议使用realloc的这些功能，尤其是其free的特性。其malloc特性可以使用。

7，realloc需要注意的是，不应该使用 p = realloc(p, sizeof(char) * 10); 这是因为，当realloc失败时，p会被赋值为NULL，而p指向的原来的空间没有被free掉！当然，如果当其为NULL时就退出程序，可以不free，因为程序结束前的free是可以不做的。
   更好的做法是 ptr = realloc(p, sizeof(char) * 10); if (ptr != NULL) p = ptr;   //realloc需要注意的，还有要重新赋值！
   realloc还需要注意的是，返回值需要重新赋值给扩展的指针。因为扩展后的空间可能会改变，必须进行再次赋值！！

8，free的参数可以是空指针，此时不起作用。但是一般都会先进行空指针判断，保证传到free的参数是非空。
   free的参数不能传入指向其他对象的指针，比如变量，数组元素，栈数组空间等。这会导致未定义行为，一般会崩溃，因为程序试图free一个栈空间，而栈空间是由系统维护的。

9，free后的指针，是一个野指针（悬空指针），即只能赋值而不能引用！
   free产生的野指针，最难发现的是，含有多个分配空间的指针别名。这样free了其中一个，其余的别名就也成为了野指针！所以，动态分配的空间的指针最好不要存在别名！

10，仍旧需要注意，struct book *book = malloc(sizeof(book)); 与 struct book *book = malloc(sizeof(*book))的区别。
    前者只分配一个指针的长度，因为book是一个指针！后者才是正确的，分配的是一个struct book结构的长度。后者等价于sizeof(struct book);建议使用后者方式，不含糊。

11，->运算符是通过指针访问时就需要。这和访问的成员是否是指针无关。
    只要是结构体指针，欲要访问其成员，就得使用->访问。
    那么，为什么会混淆呢？ 主要是因为有下面这种做法：
    struct book {
       struct book *next;
       int id;
    }
    与
    struct book {
       struct book next;
       int id;
    }
    同样是struct book *book; 第一种访问是，book->next->id; 第二种访问是，book->next.id
    无论哪种，其实道理都是一样的，只要是结构体指针，则访问成员使用->。
    book->next等价于 (*book).next
    
11，重点： 现在有一块已开辟的空间，你要存储一个字符串数组和一个book结构体数组，那么如何做？
    字符串： char **strs;   strs = (char **)buffer;
    结构体: struct book *books;   books = (struct book *)buffer;
    问题： 为什么一个用指针的指针，一个用结构体指针呢？
    解答：   整型是int，那么整型数组是int *;
            字符串是char *, 那么字符串数组是 char **;  （其实，你当其是char *强制使用，其实也没有问题的，都是一个指针值）
            结构体是struct book，那么结构体数组是 struct book *;
            因此，上面可以理解了吧。
    注： 如果这是一个属性，则只能是使用struct book *这种形式，而不能是struct book[];
    当且仅当在形参中，struct book[]才与struct book *等价。其他情况则有可能编译出错！ 
    作为属性：
    struct {                    struct {
        struct book[];  并不等价    struct book *;  强烈建议使用后者！
    }                           }
    其实很容易理解的：
    str[1] = 整型int，那么，数组是int *;
    str[1] = 字符串char*，那么，数组是char **;
    str[1] = 结构体struct book，那么，数组就是struct book*;
    
12，遍历链表惯用法： for(p = first; p != NULL; p = p->next) { .. }

13，要修改int变量的值，需要传入int变量的地址。
    要修改指针变量的指向(值)，需要传入指针变量的地址。换句话就是指针的指针。

14，函数指针：  像数组一样，f(double)中，f()是函数调用。f函数名被看作是函数指针。
    double (*f)(double); 或 double f(double); 都合法。前者是函数指针，后者是函数声明，效果都一样。
    如： double qsort(double (*f)(double), double a, double b); 和
        double qsort(double f(double), double a, double b); 效果一致。
 
    函数指针的调用。函数指针double (*f)(double);
    调用函数可以用 double a = (*f)(1.23);
          也可以用 double a = f(1.23);
    即C语言里，函数指针和函数名其实是没有区别的。函数指针可以当函数名使用。函数名可以当函数指针使用。虽然f(1.23)会更自然，但更偏向于第一种，因为可以提醒f只是一个函数指针，而不是一个实在的函数。

15，函数指针是非常有用的：1，构建回调函数。2，函数数组来组成命令菜单，根据选择返回一个函数指针。3，传入函数指针以实现同一个模块而有不同的效果。

16，C99的受限指针。使用restrict关键字声明的指针叫受限指针。意思是，这个指针不是别名。
    1，用于说明参数指向的空间只能通过该参数访问。换言之，用于说明，参数不是别名。
       如 memcpy(void * restrict s1, const void * restrict s2, size_t n); 表示s1和s2是不同的，分别指向不同的空间。
       这样，可以让编译器作优化，而无需考虑s1和s2有交集。
       但是，含有这个关键字并不是说明不能传入s1和s2有交集的指针，只是暗示，如果这样做，不能保证函数正确执行！！
 
    2，受限指针意思是不能含有别名。所以，如果p是受限指针，*qq = p的执行是未定义的，因为试图创建一个别名！

    总结： restrict关键字一般很少用，只有高级C程序员才会用，其一般用于程序的微调，即通过编译器优化，得到程序性能提升，达到最佳性能。

17，C99的灵活数组成员。
    C89标准并不能保证struct hack工作，也不允许数组长度为0.
    struct hack是指： 
    struct vstring{
       int len; 
       char chars[1]; //或 char chars[0];
    }
	然后在需要时，动态创建字符串长度 malloc(sizeof(vstring) + n -1);  // n个字符。
    由于C89的局限性和这种情况的需要，C99提供灵活数组成员，即结构体最后一个成员是数组时，可以省略长度，这貌似和struct hack没有区别。
    struct vstring {
		int len;
		char chars[];
	}
	区别： 其实是有区别的，因为灵活数组成员并不占用空间！即sizeof(vstring)时，是忽视了chars的长度的！
    所以，动态分配时，字符串空间为n，则malloc(sizeof(vstring) + n)即可，chars在sizeof中不占用空间！
   
    灵活数组成员有很多限制：
    1，灵活数组成员必须在结构体的最后。
 	2，必须至少还有一个其他成员。
	3，复制包含灵活数组成员的结构时，不复制灵活数组本身。
	4，具有灵活数组的结构体是不完整类型。不完整类型有很多限制。1，不能成为其他结构体的成员或数组的元素。
	注： 不完整类型不能构建固长数组。

18，NULL宏其实是0，提供NULL宏只是为了避免混淆，表示给指针赋值为NULL而不是使指针的值为整数0.也暗示赋值的变量是一个指针变量。
	
19，为什么是#define NULL (void *) 0 有什么好处？
    帮助编译器检查空指针的不正确使用。例如试图将NULL赋值给一个整型变量。如果定义为0，则是合法的，但是上述做法则是错误的。

20，既然用0作为空指针，那么空指针就是各位都是0的地址，是吗？ 错的！不一定。
    编译器可能会将0指针转换为为适当的内部形式，有些会使用不存在的内存地址，这样硬件就可以检查出试图通过空指针访问内存的形式。

21，用NULL作为空字符可以接受？ 绝对不可以！
	1，不同编译器对NULL宏的处理不同，不可以保证都适用。比如上面有将不可读取的内存作为NULL，这样就不能作为空字符。
	2，NULL一般是(void *)0，将其作为非指针值会导致大量混乱。
	3，一个是字符值，一个是指针值，不能混用。

22，出错信息是NULL pointer assignment。主要是因为程序使用了坏内存。（坏指针和野指针概念一样，指未初始化或NULL的指针）
	1，可能是scanf("%d", i); 忘记加&。
	2，可能是*p = i; p未初始化或设为空。

23，程序如何知道发生了“空指针赋值”？
	因为NULL通常是0，故编译器会在数据段的开始处留出“空洞”，（一般此段地址起始为0），所以如果程序没有通过空指针引用，那么段地址起始的“空洞”里是没有数据的，而如果这个“空洞”有数据，说明引用了NULL指针并且赋值了。

24，对malloc等动态内存分配函数的返回值进行强制类型转换有什么好处吗？
	一般没有好处！对这些函数返回的void *指针进行强制类型转换是没有必要的，因为会在赋值操作时自动转换为任何指针类型。对返回值进行强制类型转换的习惯来源于经典C。
	经典C中，内存分配函数返回char *类型的值，还有C89时，忘记包含内存分配的声明时，会默认返回int，所以，进行强制类型转换可以去掉这些编译时的warning。
    但是C99中已经不会了。C99中忘记包含内存分配的声明，编译器会自动添加或者会直接出错！！

25，calloc把内存块的位都初始化为0，是否意味着内存块全部数据项都是0？
	通常是，但不总是。不同类型，全部为0并不意味着值是0.如浮点数要依赖于实现。指针值要依赖于NULL值的实现。

26，malloc总容易出现分配的内存过大或过小，malloc有没有更安全的用法？ 有。
	在对单个对象分配内存时，一些程序员习惯p = malloc(sizeof(*p)); 这可以保证分配到的内存大小是正确的。
	p似乎没有初始化，*p的值应该是不可访问的！但是，sizeof并不对*p求值，而是得到*p的空间长度！这不算指针引用。这不管p是未初始化还是NULL，sizeof只是得到其指针类型的长度。指针类型是有长度的，即指针的步长。这个和它的值是无关的。

27，整数相减可能会导致溢出，所以，如果相减的两个数可能是任意数，那么不要使用相减的值来作为大小比较。而用if (a > b)来比较。

声明
1，存储类型		auto static extern register 4种。 放在最前面。最多出现一种。（可见，static和extern是不可以共用的！）
	类型限定符	const，volatile。 C99： restrict	3种。可以包含0个或多个。
	类型说明符	void，char，short，int，long等。C99： inline也是。
	声明符		即标识符。

    auto 只对属于块的变量有效，自动存储期限，块作用域，无链接。并不是说auto类型自动取默认的存储类型！！

2，一个变量包含：
	1，存储期限。 静态 和 自动。
	2，作用域。	 块   和  文件。
	3，链接。	外部（多文件内共享）		内部	（文件内共享）	和   无链接（函数内，不被共享）
    全局变量： 静态，文件，外部。
	static 全局变量： 静态，文件，内部。
	局部静态变量： 静态，块，无链接。
//static不像java一样，它在C里面还会缩窄静态变量的链接。

3，register存储类型在当今编译器中已经好处不大，不过，仍旧可以用于微调程序，可以帮助编译器优化。

4，extern声明变量有效。声明函数和默认一样。就像auto声明变量和默认一样。
	所以，一般不用auto声明一个变量。不用extern声明一个外部函数。

5，const对象不可以用于常量表达式。而数组的边界必须是常量表达式。
	如： const int n = 10; int a[n]; //错的。因为const对象不能作为常量表达式。
   感觉这样也会错误是很神奇的！ 为什么会错误呢！
   C99是支持这样的。不过，只能用于局部函数。这时a[n]被看作是变长数组。但如果a是静态变量，这个例子是错误的！！
   可以对const对象取址，但是不能修改值。

   宏在数组的效果，a[MAX] 预处理后就是 a[100] 这是正常的数组声明。但是a[n]这种并不是标准的数组声明，而是C99的变长数组！！
  
   const对象不能作为常量表达式，这一点需要注意，因为平时很少会注意到这点。这是因为const int n毕竟不是常量！只是只读的变量！！

6，静态变量的初始化必须是常量。这里就可以理解上面的内容了。const int n = 10毕竟不是常量啊！ 它只是表明变量n是只读的而已！变长数组就是指数组的长度是一个变量。传统的固长数组就是指数组的长度是一个常量。所以，上面的都可以理解了。

7，同上，数组初始化时也会有常量，变量的问题。
	int a[10] = {1, N, N * 2, N}; 当N是宏定义时，它是常量。是正确的。当N是const变量时，是不合法的。当然，C99放宽了要求，在块里面，这种做法无论是常量还是变量都可以。但是在静态变量里，这种做法是始终不合法的！！！！

8，不要依赖calloc初始化为0给非整型变量初始化。必须calloc后通过赋值进行初始化！！

9，gcc使用-O才会进行内联优化。

10，内联函数的限制：1，函数中不可以定义可改变的static变量。2，函数中不能引用具有内部链接的变量。
	这些限制是因为，内联优化时会被嵌入到调用处，如果使用上面的静态变量，会导致在不同文件里或不同块里面有不同结果。

11，C99的块！ 这是非常重要的一点。
	简而言之，我们可以直接将块作为一个子函数。
	C99中，属于块的有： if/else	while	for	  switch  等等选择语句和重复语句。

    举例说明：
	int *a;
	if (bool == true)
		*a = 1;
	else
		*a = 0;
	printf("%d\n", *a);

	等价于	（C89中，并不把选择语句和重复语句看作块，所以，上下是不等价的，只在C99下等价）
	int *a;
	if (bool == true) {		//加打括号的表示块。
		*a = 1;
	} else {
		*a = 0;
	}
	printf("%d\n", *a);

	但上，上面的语句有什么问题呢？ 感觉没有，但是其实问题很大。if/else是块，将其看作一个子函数，那么，就可以轻易发现问题！
	问题在，子函数里将一个指针指向了局部变量的值，然后返回！

	在块调用完毕，*a指向的是已经释放的内存！

	正确做法： 像解决函数返回值时一样，可以返回值。 aa = 1;这样返回。这时，是通过复制值，是副本就没有问题。

12，既然说到上面的例子，那么，顺便说一下可以通过赋值来保留一个副本的类型。
	支持赋值的类型有： 基本类型，指针类型，复合类型等等。其实也就是所有类型都支持赋值。那为什么记忆中会有某些类型不支持呢？
	比如： struct book[10]; 可以通过book[2] = book[1]来赋值。 无论book内嵌多少个结构体，都是可行的，不用怀疑！如果出错，说明是逻辑错，而不是这里不能赋值！
	只是，struct book1[10]; struct book2[10]; 不可以book1 = book2；因为这是数组！
	不支持的有： 字符串，数组，但准确来说，它们不是类型！！

13，变长数组是，数组长度是非常量。固长数组是，数组长度是字面量。（字面量和常量其实是一样的，只是以前被人将const的变量称为常量，这说法是错误的！）
	const修饰的变量仍旧是变量，所以，const修饰的不是常量！！也不是字面量！！
	为了避免与常量造成理解偏差，不称常量为常量，而叫字面量！

	很多地方需要的参数必须是字面量。不是字面量则出错！ 比如：
	1，固长数组： char[字面量]
	2，switch ：  case 字面量：
	3，数组初始化： char[字面量] = {字面量，字面量，字面量}

14，作用域与链接区别？
	作用域是为编译器服务的。链接是为链接器服务的。（所谓链接，就是文件内的一个变量是外部的，这时才需要链接）
	声明是为了明确作用域，和说明是否需要链接的。
	举例，假设一个变量a，在文件A内，声明a是内部变量，那么，编译器会知道变量a的作用域。链接器因为没有发现该文件需要外部的变量，所以，没有链接。（不排除其他地方有链接）
	      同上，在文件A内，声明a为extern int a，那么，编译器会知道变量a是需要链接的（即要访问外部文件）。但是，编译器仍旧只是根据声明来处理变量a。这与链接无关。
	编译器用标识符的作用域来确定在文件的给定位置访问标识符是否合法。当编译器把源文件翻译成目标代码时，它会注意到有外部连接的名字（不含static的全局变量，外部全局变量），并最终将这些名字存储到目标文件内的一个表中（外部全局变量表）。因此，链接器可以访问到具有外部链接的名字（外部全局变量是放在那里的，其他文件可以访问也可以不访问），而内部链接的名字或无链接的名字对链接器的名字对链接器而言是不可见的（编译器没有将它们加到表中）。

15，从上一点已经可以看出，作用域 和 链接属性 是独立的。 块作用域也可以有外部链接属性。
	比如： 本文件1的函数B内使用的是外部文件2的全局变量g_int。则，在文件1内，是块作用域，而在文件2内，它是外部链接属性。
    在文件1的函数B内这样声明： extern int g_int; 那么，文件2的外部全局变量g_int在文件1内是块作用域。

16，再强调一次，C语言中，const表示“只读”而不是“常量”，所以，const对象不能用于常量表达式，不算字面值！ 所以，不能用于case，固长数组，等。

程序设计
1，虽然C语言不是专门用于编写大型程序的，但许多大型程序的确是用C语言编写的。

2，C语言的模块： 信息隐藏，抽象数据类型。其实，也是抽象，可复用性和可维护性。
   信息隐藏： 一些模块经常隐藏一些信息，这些信息是调用者无需关心的，也不必关心的，因此模块可以暴露也可以不暴露出来。一般而言，模块只暴露调用者关心的信息（可以调用模块的最少信息），或者只暴露调用者能够操作的信息（模块自身做了功能缩窄，不提供所有功能）。信息隐藏是： 用户可以不知道的就不让用户知道，用户可以知道的，亦可以不让用户看到和修改。C语言一般用static实现隐藏。
   模块属性： 高内聚，低耦合。
   模块类型： 数据池： 一些相关的变量或常量的集合，通常只是一个头文件。通常不建议将变量放在头文件中，但建议把相关常量放在头文件中。float.h limits.h等都是属于数据池。
 			 库：	 相关函数的集合。例如 string.h 是对字符串处理函数库的接口。
			 抽象对象： 一个对象和对象相关操作的集合。如果对象是不暴露在头文件，则对象是隐藏的，是抽象的。
			 抽象数据类型（ADT）： 将具体数据实现方式隐藏起来的数据类型称为抽象数据类型。即头文件不暴露数据对象的成员，只暴露数据对象的声明。调用者可以声明这类变量，但是操作这类变量必须通过该数据对象模块提供的操作方法接口（因为类型是不完整的，故外界是不知道如何操作对象的，只能通过接口）。 

3，设计程序： 设计程序的过程，要确定究竟应该定义哪些模块，每个模块应该提供哪些服务（服务即函数），各个模块之间的相互关系是什么。
   设计接口： 接口一般定了后就不要修改，修改时尽量不修改接口名而修改接口的实现！（后期维护修改接口名是大忌）

4，C语言提供的唯一的封装工具是： 不完整类型。 （描述了对象但缺少定义对象大小需要的信息）
   如 头文件中 struct book； 只是告诉编译器有结构体book，但book的结构体定义缺在c文件里，那么就称struct book；的book是不完整类型。

   上面的具有灵活数组的结构体也是不完整类型。
   
   注： 1, 不完整类型不能构建固长数组。比如 struct book[10]; 因为struct book是不完整类型，所以这种数组用法是错误的。
       2, 不完整类型不能用于声明变量！ 如 struct book book;是错误的。只能用于声明指针。
       3，不完整类型唯一能够使用的是作为指针类型。并且通过接口来动态分配内存，并初始化，然后传出结构。对于栈空间而言，不完整类型不适用。
       4，不完整类型不适用于任何栈空间。
       
       所以，如果你要使用的是栈空间，一定不能使用不完整类型进行隐藏。是做不到的。因为你根本无法声明一个不完整类型的栈变量！！（不完整类型不能声明变量）
       
5，模块的工业级要求。
	1，命名规范：  不能使用一些常用操作名create，destroy，is_empty等作为模块的函数名，因为这种命名两个模块间很容易出现函数名冲突。所以，要加上模块名。XXX_create,XXX_destroy等。
	2，错误处理：  1，直接显示信息终结程序，这是一个不错的处理方式。
				  2，为程序提供一种从错误中恢复的途径，而不是简终止程序。比如，返回值是bool，表是否操作成功。返回值是NULL或正常值，表获取是否成功等。
				  3，在程序开头调用assert宏来进行判断参数条件。
	3，通用抽象数据类型： 即一种可以传入任何类型的参数。
			 	  其中一个常见方法是，使用void *作为数据项类型。
				  缺点： 1，不适用无法用指针表示的数据。如局部栈创建的int，double等。只能是分配的空间，字符串。一般是结构体，并且结构体是通过分配内存实现。
						2，不能进行类型错误检查。
6，C不是为开发大型程序开发的。

7，C库中有什么抽象数据类型吗？
	FILE类型。最好不要试图直接修改抽象数据类型的成员。因为编译器不同可能为抽象数据类型的成员使用不同的名称。

8，除了上面的不完整的结构体，还有别的不完整类型吗？ 
   最常见的不完整类型之一是出现在声明数组但不指定数组大小。
   extern int a[]; 这个声明后，a具有不完整类型，直到遇到定义，该定义才补充了缺失的长度信息。只要还没能访问定义，则不能使用它的成员！

   C99灵活数组具有不完整类型。
   void也是不完整类型，void类型具有不同寻常的性质，它永远不能变成完整类型，所以无法声明这种类型的变量。如void a是错误的。

注： void p; 是错误的！ 上面已经说了，无法声明void类型变量。
    void *p; 是正确的！ 但是可以声明使用void类型指针。

9，不完整类型在使用上的限制：
	1，sizeof不能用于不完整类型（因为不完整类型的空间大小未知）而sizeof是计算类型的空间大小。
    2，结构体或联合体的成员不可以具有不完整类型，灵活数组除外。
    3，数据元素不可以具有不完整类型。
	4，函数定义的形参不可以具有不完整类型，函数声明里的形参除外（一般不完整类型的函数原型，参数里就是不完整类型，但是函数体的参数是不允许这样的）。
	5，编译器会调整函数定义中的每个数组形式参数为指针类型，所以会阻止其具有不完整类型。
	6，不完整类型在没遇到定义时，不能访问未补充完整的成员！！，此时它们是不可见的。只有在定义补充完整后，才能访问成员。

底层程序设计
1，如果程序要关心不该关心的事，那么这门语言是低级的。

2，为了可移植性，最好仅对无符号数进行移位运算。

3，移位时，左移右侧补0。右移有实现定义，一般，右移左侧补符号位。

4，移位运算符的优先级比算术运算符的优先级低，因此，i << 2 + i 是 i << (2 + i)
	优先级：  | ^ & ~  (左低右高)
5，为了底层程序的移植性更好，高位我们一般不用直接赋值，而用取反。比如，要除了低5位外，高位全为1，则使用 ~0x1f，这样可以避免在不同设备上移植。
	要所有位为1，使用~0。

6，运算符&，^，和 | 的优先级比关系运算符和判等运算符低。 所以，先会进行比较，再进行移位操作。

7，用位运算符访问位。
	位设置： i |= 1 << j
    位清除： i &= ~(1 << j)
	位测试： if (i & 1 << j)
    一般用途：  
   static const long
   flag_next             = 1 << 0,	//下一个
   flag_reproc           = 1 << 1,	//重做
   flag_need_comma       = 1 << 2,
   flag_seek_value       = 1 << 3, 
   flag_escaped          = 1 << 4,
   flag_string           = 1 << 5,
   flag_need_colon       = 1 << 6,
   flag_done             = 1 << 7,
   flag_num_negative     = 1 << 8,
   flag_num_zero         = 1 << 9,
   flag_num_e            = 1 << 10,
   flag_num_e_got_sign   = 1 << 11,
   flag_num_e_negative   = 1 << 12,
   flag_line_comment     = 1 << 13,
   flag_block_comment    = 1 << 14;
	增加一个标记： flags |= flag_reproc;
	移除一个标记： flags &= ~ flag_reproc;
	检测一个标记： if (flags & flag_reproc) == true
	同时设置，清除或测试几个位：
		flags |= flag_next | flag_reproc
		flags &= ~(flag_next | flag_reproc)
		if (flags & (flag_next | flag_reproc))	
	标记都是并列关系。类似汇编的什么状态位，类似Windows的窗口样式标识等等。
	也可以作为枚举：
    enum flag {
		flag_next   = 1 << 0,
		flag_reporc = 1 << 1,
	}

8，用位运算符访问位域。处理单个位比处理位域要简单。
	修改位域：  i = i & ~0x0070 | 0x0050;   // stores 101 in bits 4-6
			   i = (i & ~0x0070) | (j << 4)  	// stores j in bits 4-6
				因为优先级|最低，所以可以去掉括号。
	获取位域：  j = i & 0x0007				//retrieves bits 0-2
			   j = (i >> 4) & 0x0007  		//retrieves bits 4-6

9，结构中的位域。
	上面的可以操作位域，但是不容易使用。C语言提供了另一种选择——声明结构的成员为位域。
	如 struct file_date {
            unsigned int day: 5;    //无符号整型中的5位。
            unsigned int month: 4;  //无符号整型中的4位。
            unsigned int year: 7; 
       };
    这是DOS存储时间的结构。
    最好不要使用int作为位域，而用unsigned int或signed int，因为int会有二义性，有的编译器会将位域的最高位作为符号位。所以最好不用int。
   
    C99中，位域可以为_Bool或其他类型。
    
    结构中的位域，访问是 struct file_data fd; fd.day = 28; fd.month = 12; fd.year = 8; //8是相对于1980年，即这是1988年。
    
  注：  结构中的位域，不能用scanf(&)输入！！！！ 你可以用一个整型获取，然后赋值： fd.year = n;

10，位域的存储。位域的存储顺序是由实现决定的。
    不过，你可以控制位域的间隔：
    struct file_time {unsigned int seconds: 5; unsigned int minutes: 6; unsigned int hours: 5;};  //秒是5位，是因为DOS下秒只存储秒数/2
    上面和这是一样的，不过不可以访问seconds，即是间隔而已：
    strcut file_time {unsigned int : 5; unsigned int minutes: 6; unsigned int hours: 5;};
    
    struct s {unsigned int a: 4; unsigned int : 0; unsigned int b: 8;};
    如果位域长度为0，表示下一个位域在一个存储单元的起始位置对齐。假如存储单元是8位长，编译器给a分配4位，跳过余下4位，然后给b分配8位。假如存储单元是16位长，编译器给a分配4位，跳过余下12位，然后给b分配8位。即以0为对称。

11，BYTE 一般是 unsigned char

12，volatile类型限定符。
    如果一个内存的数据是“易变”的，但是有的编译器会将该变量优化，而不会每次都重新冲内存里读取该空间的值。
    volatile类型限定符就是告诉编译器，该变量的内存是易变的，每次访问都重新从内存获取。

13，&和| 与 &&和|| 是不同的。
    i & j 是按位与的结果是真或假。
    副作用： i & j++始终会使j自增。而计算 i && j++有时会使j自增。

标准库
1，C89有15个，C99有24个。
   assert.h     诊断。一旦检查失败，程序终止。不是调试级！
   signal.h     信号处理。signal函数设置回调，raise函数产生信号。
   stdlib.h     常用实用程序。字符串与数值转换，伪随机数，随机数，内存管理，系统通信，搜索，排序，字节与宽字符转换等等无法划归其他头的函数。
   stdarg.h     可变参数。提供用于编写参数个数可变的函数。
   string.h     字符串处理。
   ctype.h      字符处理。大小写，字符分类。
   limits.h     整数类型大小。 最大值和最小值
   errno.h      错误。
   locale.h     本地化。 针对某个国家或地区，数的显示方式，货币格式，字符集，日期和时间的表示方式等等
   stddef.h     常用定义，经常使用的类型和宏的定义。
   time.h       时间和日期。获取时间，操作时间，格式化时间等。
   math.h       数学计算。三角函数，双曲函数，指数函数，对数函数，幂函数，邻近取整函数，绝对值运算函数，取余函数等。
   float.h      浮点类型特性。 精度，范围
   setjmp.h     setjmp标记程序中的一个位置，longjmp返回被标记的位置。用于从一个函数跳到另一个函数，主要用于处理严重错误。
   stdio.h      输入/输出。  大量输入输出函数，包括顺序访问和随机访问操作。
   
   inttypes.h   整数类型格式转换。
   complex.h    复数运算。
   iso646.h     拼写转换。定义了可代表特定运算符的宏。当编程环境中没有这些字符集的时候，非常需要。
   stdbool.h    布尔类型和值。定义了bool，true和false宏，和一个测试是否已定义这些宏的宏。
   tgmath.h     泛型数学。
   fenv.h       浮点环境。可以判断浮点运算过程是否溢出，控制如何进行取整。
   stdint.h     整数类型。指定宽度的整数类型，并定义相关的宏。
   wchar.h      扩展的多字节和宽字符使用工具。输入输出宽字符函数。
   wctype.h     宽字符分类和映射实用工具。对宽字符的分类和修改函数。

2，#include的顺序无关，次数无关。

3，1，由一个下划线和一个大写字母开头 或 由两个下划线开头的标识符 是标准库保留的标识符。_AXX | __XXX
   2，有一个下划线开头的标识符 保留用于具有文件作用域的标识符或标记。除非在函数内部声明，否则不应该使用这种。_XXX
   3，标准库中所有具有外部链接的标识符被保留用于外部链接的标识符。而且，所有标准库的函数名是被保留的，不能定义同名函数！
   
4，使用宏隐藏函数
    <stdio.h>中，将getchar()定义为宏。也有int getchar(void);声明。
    #define getchar() getc(stdin)
   要取消宏：
   1，使用#undef
    #include <stdio.h>
    #undef getchar      //注，宏不存在，#undef不会起任何作用。
   2，使用括号
    ch = (getchar)();  //这样，是getchar而不是getchar()宏，所以宏不起作用。但是，预处理后，仍旧是getchar(), 编译器仍旧识别到getchar()，而认为它是一个函数！ 

5，为什么是标准头而不是标准头文件？
    标准头不一定是文件，只不过大部分编译器确定将标准头以文件形式存储。其实，标准头可以内嵌到编译器中。

6，之前提到，带参数宏代替函数的缺点，带参数宏代替函数是不是很危险？ 不是。
    根据C标准，用于替代库函数的带参数的宏必须用圆括号“完全保护”起来，而且只能对参数进行一次求值。这些规则可以避免上面提到的缺点。
    
7，向文件写入数据时，我们需要考虑是按文本格式存储还是按二进制格式进行存储。

8，二进制存储与大小端有关。

9，Windows下也可以使用/作为目录路径

10，永远不要假设可以打开文件，每次都要测试fopen函数的返回值以确保不是空指针！！

11，读和写模式： （重要）
    1，如果没有先调用一个文件定位函数，那么就不能从读模式转换为写模式！除非，读操作已经读到了文件末尾。
    2，类似，如果既没有调用fflush函数，也没有调用文件定位函数，那么就不能从写模式转换为读模式。

12，如果fclose成功，返回0，失败返回错误代码EOF。

13，使用setvbuf函数或zetbuf函数时，一定要确保在释放缓冲区之前已经关闭了流，特别是，如果缓冲区是局部于函数的，并且具有自动存储期限，一定要确保在函数返回之前关闭流。
    不关闭流，数据不会被冲洗到磁盘。关闭流有两种方式：1，关闭文件。2，关闭流。
    
14，如果打开了要改名的文件，那么一定要确保在调用rename函数之前关闭此文件，对打开的文件执行改名操作会失败。

15，%lc，%ls用于输出宽字符。

16，C89中未定义的%le，%l，%lf，%lg，%lG是未定义的，在C99中可以使用了。虽然没有作用，l长度修饰符被忽略，输出时是不需要l的，输入时才需要。

17，scanf和printf一样，如果格式串里有未定义的说明，会导致未定义的行为。

18，始终要把fgetc，getc或getchar函数的返回值存储在int型中，而不是char类型中，把char类型变量与EOF比较可能会得到错误的结果。
    （这一点貌似从没有用过，很多程序也不用这样吧）

19，fread和fwrite的特色：
    1，fread(a, 1, 100, fp); 返回值范围是 0-100        读入100块1长度数据，返回读到了多少块。
    2, fread(a, 100, 1, fp); 返回值范围是 0-1          读入1块100长度数据，返回读到了多少块。

    3，fwrite(&s, sizeof(s), 1, fp); 返回值范围是 0-1   写入1块结构体s的长度，返回写入了多少块。
    4，fwrite(a, 1, 100, fp); 返回值范围是 0-100
    5，fwrite(a, 100, 1, fp); 返回值范围是 0-1

注： fwrite输出指针的值时需要注意，一般来说，指针值是不应该输出到文件的，因为每次程序的内存是不同的。所以，读回时，该指针值是无法保证和上一次执行时指针值一致！

20，fseek(fp, 0L, SEEK_SET);         //移到文件开头        成功返回0，失败返回非0 
    fseek(fp, 0L, SEEK_END);        //移到文件末尾
    fseek(fp, -10L, SEEK_CUR);      //当前位置向前10字节
    rewind(fp);                     //回到文件头。            无返回值
    ftell(fp);                      //获得读写指针当前位置，二进制返回的是字节，文本方式不一定是字节。最好不要将ftell返回值用于运算。
                                      有获取文件大小的方式是，移到文件尾，使用ftell获取长度值。  成功返回位置值，失败返回-1L，并设置errno

21，在Unix中，没有文本与二进制之分，都是二进制。但是还是应该在打开方式里使用b，方便移植。

22，为什么要调用fclose关闭文件，程序退出时它不是会自动关闭吗？ 
    通常会这样，但是程序Abort终止程序时，是不会这样处理的。而且，关闭文件可以1，释放文件描述符系统资源。2，容易修改，知道文件在哪里之后已经不需要了，而且可以确保文件能够更新。
    
23，我想打开一个文件，但是文件的名字多长呢？ 这与系统相关，而一般宏FILENAME_MAX来指定数组长度。在stdio.h里。

24，fflush可以清除同时为读和写而打开的流吗？ 
    根据C标准，当流为输出打开，或为更新打开并且最后一个操作不是读时，调用fflush才有意义。其他情况，都是未定义的。
    对fflush(NULL)传入参数NULL，它会清除所有为输出打开的流，或者为更新打开的流。

 

















