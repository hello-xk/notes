assert的使用：

注：assert宏只在调试版本中有效，在发行版本中，assert宏是没有作用的！

assert是用来方便调试的。一般用于逻辑上一定不会出现错误的地方，也常用于逻辑上不能出现的地方。



1，用于不应该出现的情况的地方：
    switch (type) {
    case GET: break;
    case PUT: break;
    case POST: break;
    case DELETE: break;
    default: assert(0);break;   //程序运行过程，不应该出现这个情况，如果出现，说明逻辑上有错误。因为type只能是 http方法 这几种值。这个时候，如果出现这个例外的数值，说明有地方不合法调用，有可能是参数未初始化导致的问题，这样的assert能够在测试中找到出错的原因，并能够修复。
    }
    
2，用于不可能出现的地方：
    if (bl) {
        is_true = 1;
    } else {
        is_true = 0;
    }
    ....
    ....
    assert(is_true == 0 || is_true == 1);  //根据上面的逻辑，is_true应该只能是1或者0.如果出现其他值，说明上面处理出了问题。
    if(is_true) {
        ...
    } else {
        ...
    }

3，用于防止一些参数修改导致的逻辑问题。如缓冲足够是不会有错误的，修改了缓冲的大小后，可能会导致错误，这时，assert断言能够帮助程序员意识到这个错误的存在。    
    char data[1024];
    char *buf = str;
    int offset = 0;
    int rest = sizeof(data) - 1; //预留一个空间给 '\0'
    int i;
    for (i = 0; rest > 0; i++) {
        offset = snprintf(buf, rest, "1.12,");
        if (offset >= rest)  //不够写入，则退出。如果第一次就不够，那么会直接退出。
            break;
        buf += offset;
        rest -= offset;
    }
    //目的是生成这样一个字符串 "1.12,1.12,1.12~" 或者，最低限度是 "1.12~"，说明循环必须至少执行一次！！！
    //因为预留了一个，所以sizeof(data) > rest一定成立，否则，说明上面的操作异常。
    assert(i > 0 && sizeof(data) - rest > 0);  //上面的执行，结果一定要 循环成功被执行一次以上，且 sizeof(data) > rest ，因为这是逻辑上处理的，如果不是，则说明处理过程出现了问题！循环一次以上，是为了下面能够替换","，因为一次都没循环的话，是没有逗号的！
    snprintf(buf - 1, 2, "~");  //替换最后一个的","为"]"，
    
    这里，assert的作用是，第一，保证逻辑上的正确，第二，有时候，会修改data[1024]这个缓冲，如果不小心修改为data[2],那么程序将一次都没循环，这与要求不符合（至少生成完整的一个），所以，程序的不通过可以让程序员意识到，更改导致了逻辑上的问题。assert在这里就防止了更改代码后导致的逻辑上不符合和一些可能的内存溢出。如果代码是由多个人合作的，那么这里就很有必要，最好做上注释，就更好。就是为了防止别人修改了，却因为数值上的变化导致逻辑上的错误！
    
4，assert还常用于保证参数的正确性上。
    void book_init(struct book *book, const char *name) {
        assert(book != NULL);
        strncpy(book->name, name, BOOK_NAME_LEN);
    }    
    
    这里用assert 和 if (book == NULL) {printf("book is null\n"); return;} 哪个好呢？    
    分析： 这里主要是使book结构体初始化，如果book为空，就是逻辑上的错误，不应该出现，出现的时候，就说明调用错误了，使用if的话，多此一举，且通过打印信息输出，目的还是让程序员来修复这个问题。所以，这里就直接用assert就可以了。
    那什么时候才需要用if来判断呢？
    用if来判断时候，是这个值是NULL还是其它值都是有代表的，有意义的，换言之，NULL值也是其正常值的范畴，那么就可以用if。通常是属性的时候才会这样。
    比如一个回调函数on_callback，这个指针为NULL，并不是说逻辑上错误，而是说，没有设置回调函数。而上面的例子，book为NULL说明调用错误了，book不应该出现NULL值，这不是一个正常值，也不是一个有意义的值。
    
    void 
    string_copy1(char* dest, const char* source) 
    { 
      assert(dest != NULL); /* 使用断言 */ 
      assert(source != NULL); 
      
      while (*source != '\0') {  
    这里不应该使用if，如果dest和source为NULL，它应该算一种错误，而不是一个正常值范畴！这样做有什么好处呢？
    如果使用if，当为NULL时则结束，这样有隐患。比如，你做了string_copy这个操作，结果发现字符串没有被复制到，那应该从哪里寻找错误呢？如果这里使用assert，如果没有断言输出，则说明，这个函数里是没有问题的，那么问题就只能出现在其它地方，如果断言输出，说明函数使用错误。相反，if并不能有任何帮助，反而使得我们还得关心string_copy这个函数的内部，本来这些库函数目的就是为了我们不必进入到它的内部，不用了解它们，使用它们就好了，而现在变得要了解库函数里面的逻辑如何了。所以，其实我们不应进入了解它的逻辑，使用assert的话，有错误就会输出断言，告诉我们这个函数使用出错了，我们就知道参数错误了！用if根本是画蛇添足。
    如果用if，那么，对不同的处理，需要使用返回值进行说明，比如-1表示没有复制，大于1表示复制成功。
    这种情况要不要加返回值来进行呢？个人觉得不必要，但是有的人认为，这是库函数，参数为NULL应该属于正常参数范畴，就是不进行复制而已。当然，可以这样做。
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
