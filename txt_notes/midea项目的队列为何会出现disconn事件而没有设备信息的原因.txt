为什么midea的队列会出现disconnected事件而没有设备信息呢？明明已经采用了key-value来不提交重复的请求。
原因： 这个原因是错的，见下面。
    正在发送是A，队列是： B C D 
    A正在发送，因为设备已经移除，所以需要等待timeout 800ms，A已经不在队列里，A的请求还没返回，维护的列表里仍旧认为A B C D设备都存在。
    A正在发送，此时新的monitor监视已经过来（monitor的频率太高），产生了A B C D这样的请求。
    B C D因为还在队列，所以不会被添加，但是A已经不在队列里了，所以A还是会被添加到发送队列。
    于是，可见，A的请求会被重复发送2次，归根到底，是没有把当前发送的请求也进行比较，判断新的请求是否已存在。

解决：
    1，将monitor监视的频率调小点，但是这是治标不治本。
    2，将正在发送项也做为重复项比较。（这就导致，A正在发送时，还是不能将A移除出栈）
    3，一个请求一个请求地发。A发完后才发B，这样就不会有重复项产生，monitor就不用做成定时器，每个周期地产生一堆请求，占用发送缓存。

问题回归： monitor的频率是 1次/s  而A请求的timeout是800ms，下一次monitor到来时，A请求要么有回应，要么有timeout才是啊？！为何？？

原因： A正常回应，包含读写，解析模块，这些模块工作的时候，timer是一直在计算的。尤其是读写模块，在串行设备上会相印会慢些，读写部分花费应该超过1秒。但是也不对！ 如果读写超过800ms就是timeout了，但是timeout没有产生！!  实际测试，A正常回应，花费110ms。
      Atimeout，不止800ms？ A的请求包含读写，写超时是800ms，读超时是800ms。换言之，A请求包含写入时间+读回timeout，这个值是否超过1s？如果超过，则A请求还没返回，下一个monitor就会产生。 实际测试，Atimeout时，到下一个请求总花费800ms。没有变大！
      
      那么，产生请求重复的不是因为A的原因。而是因为队列的设计缺陷！
      A发送完，立即发送下一个请求。然后下一个monitor就产生了。真正导致问题的是这个：
      
      正在发送A，队列是： B C D
      A超时800ms，然后立即发送B，B正在发送。此时B的超时还没到。但是monitor的1s间隔已经到了。
      正在发送B，monitor产生请求 B C D。（A的请求已经返回，因此monitor已经知道A被移除），于是B被重复添加了。
      
      只要队列里还有请求，则不能进行下一个monitor，否则总会出现重复项！因为下一个monitor总会重复添加正在发送中的那个请求，所以，只要队列还没发送完monitor就触发，那么就一定会重复添加了一个。而且，每触发一次monitor，就多重复添加一个。
      
解决：
    1，将monitor的频率调动是可以完全修复这个bug的，就是monitor的下一次频率 = 队列长度 * timeout。但是，这样，就不能及时检测到设备是否被移除。（因为设备不超时，是很快就返回的，于是，monitor就白白在等待，而没有在监视，也就起不到监视作用。）
    2，将正在发送项也做为重复项比较。（这就导致，A正在发送时，还是不能将A移除出栈）
    3，一个请求一个请求地发。A发完后才发B，这样就不会有重复项产生，monitor就不用做成定时器，每个周期地产生一堆请求，占用发送缓存。
    
    
二，为何aircond结构体使用memcmp比较时不等的问题。
原因： 不等就代表结构体真的不等。原因很简单，就是忽视了aircond里面的struct list_head list_member; 这个成员。
      list的列表里，aircond这个list_member的成员总不等的！！所以，直接比较aircond结构体当然得到两个结构体都不等。
      
解决：
      分开比较。先比较aircond->addr成员，再比较aircond->settings成员，而不是整个aircond结构体比较！！
      
      
